<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- Copyright (C) 2019 SIFT, LLC.
Original materials (C) 2002 University of Maryland.

This document is made available under the Creative Commons
Attribution-ShareAlike 4.0 International Public License -->
<!-- Created by GNU Texinfo 6.6, http://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>SHOP3 Manual</title>

<meta name="description" content="SHOP3 Manual">
<meta name="keywords" content="SHOP3 Manual">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<link href="#Top" rel="start" title="Top">
<link href="#Function-Index" rel="index" title="Function Index">
<link href="#SEC_Contents" rel="contents" title="Table of Contents">
<link href="dir.html#Top" rel="up" title="(dir)">
<style type="text/css">
<!--
  

a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
ul.no-bullet {list-style: none}
.node { visibility:hidden; height: 0px; }
  .menu { visibility:hidden; height: 0px; }
  .appendix { background-color:#a4bbff; padding: 0.2em; }
  .chapter { background-color:#a4bbff; padding: 0.2em; }
  .section { background-color:#a4bbff; padding: 0.2em; }
  .settitle { background-color:#a4bbff; }
  .contents { border: 2px solid black;
              margin: 1cm 1cm 1cm 1cm;
              padding-left: 3mm; }
  .lisp { padding: 0; margin: 0em; }
  body { padding: 2em 8em; font-family: sans-serif; }
  h1 { padding: 1em; text-align: center; }
  li { margin: 1em; }


-->
</style>


</head>

<body lang="en">
<h1 class="settitle" align="center">SHOP3 Manual</h1>











<span id="SEC_Contents"></span>
<h2 class="contents-heading">Table of Contents</h2>

<div class="contents">

<ul class="no-bullet">
  <li><a id="toc-Introduction-1" href="#Introduction">1 Introduction</a></li>
  <li><a id="toc-Execution-Environment-1" href="#Execution-Environment">2 Execution Environment</a></li>
  <li><a id="toc-Running-SHOP3-1" href="#Running-SHOP3">3 Running <small>SHOP3</small></a>
  <ul class="no-bullet">
    <li><a id="toc-Loading-the-Planner-1" href="#Loading-the-Planner">3.1 Loading the Planner</a></li>
    <li><a id="toc-Executing-the-Planner-1" href="#Executing-the-Planner">3.2 Executing the Planner</a>
    <ul class="no-bullet">
      <li><a id="toc-FIND_002dPLANS" href="#find_002dplans">3.2.1 <code>FIND-PLANS</code></a></li>
      <li><a id="toc-FIND_002dPLANS_002dSTACK" href="#find_002dplans_002dstack">3.2.2 <code>FIND-PLANS-STACK</code></a></li>
      <li><a id="toc-DO_002dPROBLEMS" href="#do_002dproblems">3.2.3 <code>DO-PROBLEMS</code></a></li>
      <li><a id="toc-Common-Keyword-Arguments-1" href="#Common-Keyword-Arguments">3.2.4 Common Keyword Arguments</a></li>
    </ul></li>
    <li><a id="toc-Tracing-1" href="#Tracing">3.3 Tracing</a></li>
    <li><a id="toc-Other-Debugging-Features-1" href="#Other-Debugging-Features">3.4 Other Debugging Features</a></li>
    <li><a id="toc-Syntax-Checks-1" href="#Syntax-Checks">3.5 Syntax Checks</a></li>
    <li><a id="toc-Debugging-Suggestions-1" href="#Debugging-Suggestions">3.6 Debugging Suggestions</a></li>
    <li><a id="toc-Hook-Routines-1" href="#Hook-Routines">3.7 Hook Routines</a></li>
  </ul></li>
  <li><a id="toc-The-SHOP3-Formalism-1" href="#The-SHOP3-Formalism">4 The <small>SHOP3</small> Formalism</a>
  <ul class="no-bullet">
    <li><a id="toc-Symbols-1" href="#Symbols">4.1 Symbols</a></li>
    <li><a id="toc-General-Lisp-Expressions-1" href="#General-Lisp-Expressions">4.2 General Lisp Expressions</a></li>
    <li><a id="toc-Terms-1" href="#Terms">4.3 Terms</a>
    <ul class="no-bullet">
      <li><a id="toc-List-Terms-1" href="#List-Terms">4.3.1 List Terms</a></li>
      <li><a id="toc-Eval-Terms-1" href="#Eval-Terms">4.3.2 Eval Terms</a></li>
      <li><a id="toc-Call_002dterms-1" href="#Call_002dterms">4.3.3 Call-terms</a></li>
    </ul></li>
    <li><a id="toc-Logical-Atoms-1" href="#Logical-Atoms">4.4 Logical Atoms</a></li>
    <li><a id="toc-Logical-Expressions-1" href="#Logical-Expressions">4.5 Logical Expressions</a>
    <ul class="no-bullet">
      <li><a id="toc-Conjuncts-1" href="#Conjuncts">4.5.1 Conjuncts</a></li>
      <li><a id="toc-Disjuncts-1" href="#Disjuncts">4.5.2 Disjuncts</a></li>
      <li><a id="toc-Negations-1" href="#Negations">4.5.3 Negations</a></li>
      <li><a id="toc-Implications-1" href="#Implications">4.5.4 Implications</a></li>
      <li><a id="toc-Universal-Quantifications-1" href="#Universal-Quantifications">4.5.5 Universal Quantifications</a></li>
      <li><a id="toc-Assignments-1" href="#Assignments">4.5.6 Assignments</a></li>
      <li><a id="toc-Eval-expressions-1" href="#Eval-expressions">4.5.7 Eval expressions</a></li>
      <li><a id="toc-Call_002dexpressions-1" href="#Call_002dexpressions">4.5.8 Call-expressions</a></li>
      <li><a id="toc-Enforce_002dexpressions-1" href="#Enforce_002dexpressions">4.5.9 Enforce-expressions</a></li>
      <li><a id="toc-Setof_002dexpressions-1" href="#Setof_002dexpressions">4.5.10 Setof-expressions</a></li>
      <li><a id="toc-Bagof_002dexpressions-1" href="#Bagof_002dexpressions">4.5.11 Bagof-expressions</a></li>
    </ul></li>
    <li><a id="toc-Logical-Precondition-1" href="#Logical-Precondition">4.6 Logical Precondition</a>
    <ul class="no-bullet">
      <li><a id="toc-First-Satisfiers-Precondition-1" href="#First-Satisfiers-Precondition">4.6.1 First Satisfiers Precondition</a></li>
      <li><a id="toc-Sorted-Precondition-1" href="#Sorted-Precondition">4.6.2 Sorted Precondition</a></li>
    </ul></li>
    <li><a id="toc-Axioms-1" href="#Axioms">4.7 Axioms</a></li>
    <li><a id="toc-Task-Atoms-1" href="#Task-Atoms">4.8 Task Atoms</a></li>
    <li><a id="toc-Task-Lists-1" href="#Task-Lists">4.9 Task Lists</a></li>
    <li><a id="toc-Operators-1" href="#Operators">4.10 Operators</a>
    <ul class="no-bullet">
      <li><a id="toc-Operators_003a-Legacy-Syntax" href="#Operators-Legacy-Syntax">4.10.1 Operators: Legacy Syntax</a></li>
    </ul></li>
    <li><a id="toc-Methods-1" href="#Methods">4.11 Methods</a></li>
    <li><a id="toc-Planning-Domain-1" href="#Planning-Domain">4.12 Planning Domain</a>
    <ul class="no-bullet">
      <li><a id="toc-Simple-Form-1" href="#Simple-Form">4.12.1 Simple Form</a></li>
      <li><a id="toc-Extended-form-1" href="#Extended-form">4.12.2 Extended form</a></li>
      <li><a id="toc-Inclusion-directives-1" href="#Inclusion-directives">4.12.3 Inclusion directives</a></li>
    </ul></li>
    <li><a id="toc-Planning-Problem-1" href="#Planning-Problem">4.13 Planning Problem</a></li>
    <li><a id="toc-Planning-Problem-Set-1" href="#Planning-Problem-Set">4.14 Planning Problem Set</a></li>
    <li><a id="toc-Plans-1" href="#Plans">4.15 Plans</a></li>
  </ul></li>
  <li><a id="toc-PDDL-Support-1" href="#PDDL-Support">5 PDDL Support</a>
  <ul class="no-bullet">
    <li><a id="toc-PDDL-Methods-1" href="#PDDL-Methods">5.1 PDDL Methods</a>
    <ul class="no-bullet">
      <li><a id="toc-Enhanced-Preconditions-1" href="#Enhanced-Preconditions">5.1.1 Enhanced Preconditions</a></li>
      <li><a id="toc-PDDL-Domain-Classes-1" href="#PDDL-Domain-Classes">5.1.2 PDDL Domain Classes</a></li>
    </ul></li>
  </ul></li>
  <li><a id="toc-The-SHOP-Theorem-Prover-1" href="#The-SHOP-Theorem-Prover">6 The SHOP Theorem Prover</a></li>
  <li><a id="toc-The-SHOP-Unifier-1" href="#The-SHOP-Unifier">7 The SHOP Unifier</a></li>
  <li><a id="toc-Plan-Grapher-1" href="#Plan-Grapher">8 Plan Grapher</a></li>
  <li><a id="toc-Internal-Technical-Information-1" href="#Internal-Technical-Information">9 Internal Technical Information</a>
  <ul class="no-bullet">
    <li><a id="toc-Internal-Knowledge-Structures-1" href="#Internal-Knowledge-Structures">9.1 Internal Knowledge Structures</a>
    <ul class="no-bullet">
      <li><a id="toc-Substitutions-1" href="#Substitutions">9.1.1 Substitutions</a></li>
      <li><a id="toc-States-and-Satisfiers-1" href="#States-and-Satisfiers">9.1.2 States and Satisfiers</a></li>
    </ul></li>
    <li><a id="toc-Formal-Semantics-1" href="#Formal-Semantics">9.2 Formal Semantics</a>
    <ul class="no-bullet">
      <li><a id="toc-Semantics-of-Operators-1" href="#Semantics-of-Operators">9.2.1 Semantics of Operators</a></li>
      <li><a id="toc-Semantics-of-Methods-1" href="#Semantics-of-Methods">9.2.2 Semantics of Methods</a></li>
      <li><a id="toc-Semantics-of-Plans-1" href="#Semantics-of-Plans">9.2.3 Semantics of Plans</a></li>
    </ul></li>
    <li><a id="toc-Key-Functions-in-SHOP3-1" href="#Key-Functions-in-SHOP3">9.3 Key Functions in <small>SHOP3</small></a></li>
  </ul></li>
  <li><a id="toc-Differences-between-SHOP-1_002ex_002c-SHOP2-and-SHOP3" href="#Version-Differences">10 Differences between SHOP 1.x, SHOP2 and <small>SHOP3</small></a>
  <ul class="no-bullet">
    <li><a id="toc-SHOP-1_002ex-Syntax-Comparison" href="#SHOP-1x-Syntax-Comparison">10.1 SHOP 1.x Syntax Comparison</a></li>
    <li><a id="toc-SHOP-1_002ex-Functionality-Comparison" href="#SHOP-1x-Functionality-Comparison">10.2 SHOP 1.x Functionality Comparison</a></li>
  </ul></li>
  <li><a id="toc-General-Notes-on-SHOP3-1" href="#General-Notes-on-SHOP3">11 General Notes on <small>SHOP3</small></a></li>
  <li><a id="toc-Acknowledgments-1" href="#Acknowledgments">12 Acknowledgments</a></li>
  <li><a id="toc-References-1" href="#References">13 References</a></li>
  <li><a id="toc-Function-and-Macro-Index" href="#Function-Index">Function and Macro Index</a></li>
  <li><a id="toc-Type-and-Class-Index-1" href="#Type-and-Class-Index">Type and Class Index</a></li>
  <li><a id="toc-Variable-Index-1" href="#Variable-Index">Variable Index</a></li>
  <li><a id="toc-Concept-Index-1" href="#Concept-Index">Concept Index</a></li>
  <li><a id="toc-Colophon-1" href="#Colophon">Colophon</a></li>
</ul>
</div>



<span id="Top"></span><div class="header">
<p>
Next: <a href="#Introduction" accesskey="n" rel="next">Introduction</a>, Previous: <a href="dir.html#Top" accesskey="p" rel="prev">(dir)</a>, Up: <a href="dir.html#Top" accesskey="u" rel="up">(dir)</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="SHOP3-Manual"></span><h1 class="top">SHOP3 Manual</h1>

<div align="center"><img src="img/shop3-logo-small.png" alt="img/shop3-logo-small">
</div>
<div align="center">Robert P. Goldman<sup>1</sup>, Dana Nau<sup>2</sup>, and Contributors
</div>
<p><sup>1</sup> SIFT, LLC
</p>
<p>319 North First Avenue, Suite 400
</p>
<p>Minneapolis, MN 55401, USA
</p>
<p><sup>2</sup> Department of Computer Science
</p>
<p>University of Maryland
</p>
<p>College Park, MD 20742, USA
</p>


<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#Introduction" accesskey="1">Introduction</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Execution-Environment" accesskey="2">Execution Environment</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Running-SHOP3" accesskey="3">Running SHOP3</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#The-SHOP3-Formalism" accesskey="4">The SHOP3 Formalism</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#PDDL-Support" accesskey="5">PDDL Support</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#The-SHOP-Theorem-Prover" accesskey="6">The SHOP Theorem Prover</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#The-SHOP-Unifier" accesskey="7">The SHOP Unifier</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Plan-Grapher" accesskey="8">Plan Grapher</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Internal-Technical-Information" accesskey="9">Internal Technical Information</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Version-Differences">Differences between SHOP 1x, SHOP2, and SHOP3</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#General-Notes-on-SHOP3">General Notes on <small>SHOP3</small></a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Acknowledgments">Acknowledgments</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#References">References</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Function-Index">Function Index</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Type-and-Class-Index">Type and Class Index</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Variable-Index">Variable Index</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Concept-Index">Concept Index</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Colophon">Colophon</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>



<hr>
<span id="Introduction"></span><div class="header">
<p>
Next: <a href="#Execution-Environment" accesskey="n" rel="next">Execution Environment</a>, Previous: <a href="#Top" accesskey="p" rel="prev">Top</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Introduction-1"></span><h2 class="chapter">1 Introduction</h2>

<p>AI planning is the subfield of artificial intelligence (AI) that aims at
automating processes of <em>means-ends reasoning</em>.  In general, 
AI planning is the problem of
finding a sequence of actions that, executed in a specified initial
state, will reach a goal state.  This is a problem with applications
to diverse areas including manufacturing, autonomous space and deep
sea exploration, medical treatment, and military operations, to name
just a few.  This is the manual for <small>SHOP3</small>, the third major version
of the  Simple Hierarchical Ordered Planner.
</p>
<p>AI planning systems takes as input a <em>domain</em> &ndash; a description of
available actions, relations, etc.; a <em>problem</em> &ndash; a description of
the initial state of the system, and an <em>objective</em>, a task to be performed or goal to
be achieved.  From these, it generates a <em>plan</em>: a sequence of
actions that, if performed with the expected results, will attain the
objective.  This is the key function performed by <small>SHOP3</small>, although,
as will be seen in this manual, many additional functions are offered.
</p>
<p><small>SHOP3</small> is a domain-independent
planning system based on <strong>ordered task decomposition</strong>, a modified
version of Hierarchical Task Network (HTN) planning that involves planning for tasks in the same
order that they will later be executed. An HTN, or <em>decomposition,</em>
planner âproceeds by decomposing <em>nonprimitive tasks</em> recursively
into smaller and smaller subtasks, until <em>primitive tasks</em> are
reached that can be performed directly using the planning
operators.â<a id="DOCF1" href="#FOOT1"><sup>1</sup></a> This
manual does not give an introduction to HTN planning or AI planning in
general, for that we recommend the above-cited textbook by Ghallab,
<em>et al.,</em> and/or the research papers describing <small>SHOP3</small>.
</p>
<p><small>SHOP</small> and <small>SHOP 2</small> were originally developed at the Computer
Science Department of the University of Maryland, College Park, by
Prof. Dana Nau&rsquo;s research group.  This manual draws heavily on material
from the manual for <small>SHOP 2</small>, which was, in turn based, in part, on the JSHOP documentation written by FÃ¼sun
Yaman, with additional material from Yue Cao&rsquo;s December 2000 draft of
the <small>SHOP 2</small>  documentation and pseudocode from [Nau <em>et al</em>.,
2001].  Some updates to the <small>SHOP 2</small> manual were made by Robert
P. Goldman and John Maraist, of SIFT.
</p>
<p><small>SHOP3</small> contains two important subsystems that perform useful
functions as part of <small>SHOP3</small>, but that can be used on their own.
The first is the <em>unifier</em>, which computes the most general unifier
of two logical formulas, encoded as lisp s-expressions.
The second subsystem is the <em>theorem-prover</em>, which performs
Prolog-style rule-based Horn clause deduction over state sequences.
</p>

<p>The planners in the <small>SHOP</small> family have the following distinctive characteristics:
</p>
<ul>
<li> <small>SHOP</small> knows the current state-of-the-world at each step of the planning
process.

</li><li> It has great expressive power, far beyond that of conventional PDDL planners. 
For example, in the preconditions of
operators and methods it can do mixed symbolic/numeric computations and
execute calls to external programs.

</li><li> It can be used to create very efficient domain-specific planning
algorithms. The  software distribution includes several examples of
such domain-specific algorithms.



</li><li> <small>SHOP3</small> incorporates many features from
<a href="http://www.dur.ac.uk/d.p.long/IPC/pddl.html">PDDL</a>, e.g., support
for quantifiers and conditional effects in methods and operators.

</li><li> <small>SHOP2</small> and <small>SHOP3</small> (unlike <small>SHOP</small>) allow a combination of partially ordered and fully ordered
task networks through the use of the <code>:unordered</code> and
<code>:ordered</code> keywords.

</li><li> <small>SHOP3</small> task networks are <em>less</em> expressive than full HTN
planners such as UMCP, which have labeled tasks in their task networks and allow arbitrary
ordering constraints.

</li><li> <small>SHOP3</small> allows branch-and-bound optimization of plan costs. For small
problems, this capability can be used to find the absolute minimum cost
plans. For larger problems, this capability can be used with time limits
to get the lowest cost plan that is found within the given time limit.

</li><li> <small>SHOP3</small> adds support for the Planner Domain Description Language
(PDDL), and updates the <small>SHOP</small> language for easier domain engineering.

</li></ul>

<hr>
<span id="Execution-Environment"></span><div class="header">
<p>
Next: <a href="#Running-SHOP3" accesskey="n" rel="next">Running SHOP3</a>, Previous: <a href="#Introduction" accesskey="p" rel="prev">Introduction</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Execution-Environment-1"></span><h2 class="chapter">2 Execution Environment</h2>
<span id="g_t_0023execution_002denvironment"></span><p><small>SHOP3</small> is written in Common Lisp. To be able to run <small>SHOP3</small>, you will need
to have Common Lisp installed on your computer. We have run <small>SHOP3</small>
successfully under the following implementations of Common Lisp, and we
would be interested in hearing your reports about other implementations:
</p>
<ul>
<li> Allegro Common Lisp v. 10.x (on x86 and x86_64 Linux and Mac OSX);

</li><li> Steel Bank Common Lisp, v. 1.4+ on x86 and x86_64, Linux and Mac OSX.

</li><li> Clozure Common Lisp, version 1.11 on Mac OS X and Linux.


</li></ul>

<p>We suspect that there may be some difficulties in running <small>SHOP3</small> on
Windows; most of these have to do with getting the ASDF system
definitions to work on Windows, not with <small>SHOP3</small> proper. Please contact us
if you encounter difficulties. We welcome reports of experiences with
other platforms and CL implementations, and will attempt to support
users who wish to bring <small>SHOP3</small> up on other combinations.
</p>
<p>Note that <small>SHOP3</small> is known <strong>not</strong> to work with Embeddable Common
Lisp (ECL).
</p>
<p><small>SHOP3</small> is distributed with a system definition written using the
open-source ASDF system definition facility (for more information, see
<a href="http://common-lisp.net/projects/asdf/">http://common-lisp.net/projects/asdf/</a>). You should insure that all of the .asd
files in the <small>SHOP3</small> distribution can be found by ASDF, per the
instructions given with ASDF, and then <small>SHOP3</small> should load without any
problems. See Section 5.1 for more details about how to load <small>SHOP3</small>.
All of the CL implementations we know of ship with ASDF pre-installed.
To enable it you may have to
</p><div class="lisp">
<pre class="lisp">(require :asdf)
</pre></div>









<hr>
<span id="Running-SHOP3"></span><div class="header">
<p>
Next: <a href="#The-SHOP3-Formalism" accesskey="n" rel="next">The SHOP3 Formalism</a>, Previous: <a href="#Execution-Environment" accesskey="p" rel="prev">Execution Environment</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Running-SHOP3-1"></span><h2 class="chapter">3 Running <small>SHOP3</small></h2>
<p>The latest version of <small>SHOP3</small> is loaded by using the ASDF system
definition facility. The first of the following subsections explains how
to use ASDF to load <small>SHOP3</small>. Note that previous methods of starting <small>SHOP3</small>,
by hand-coded load files, and mk:defsystem, are no longer supported.
There are two ways to execute the <small>SHOP3</small> planning process: find-plans,
which finds plans for a single planning problem, and do-problems, which
finds plans for a planning problem set. Subsection 5.2 describes the use
of these functions. Subsection 5.3 describes the functions shop-trace
and shop-untrace, which are the primary mechanisms for debugging <small>SHOP3</small>
domain descriptions and problem specifications. Subsection 5.4 describes
some additional features that may also be useful for debugging domain
descriptions and problems for <small>SHOP3</small>. Finally, subsection 5.5 describes
some hook routines that can be used to customize the behavior of <small>SHOP3</small>.
</p><table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#Loading-the-Planner" accesskey="1">Loading the Planner</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Executing-the-Planner" accesskey="2">Executing the Planner</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Tracing" accesskey="3">Tracing</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Other-Debugging-Features" accesskey="4">Other Debugging Features</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Syntax-Checks" accesskey="5">Syntax Checks</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Debugging-Suggestions" accesskey="6">Debugging Suggestions</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Hook-Routines" accesskey="7">Hook Routines</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr>
<span id="Loading-the-Planner"></span><div class="header">
<p>
Next: <a href="#Executing-the-Planner" accesskey="n" rel="next">Executing the Planner</a>, Previous: <a href="#Running-SHOP3" accesskey="p" rel="prev">Running SHOP3</a>, Up: <a href="#Running-SHOP3" accesskey="u" rel="up">Running SHOP3</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Loading-the-Planner-1"></span><h3 class="section">3.1 Loading the Planner</h3>
<span id="g_t_0023loading_002dthe_002dplanner"></span><p>The <small>SHOP3</small> planner should be loaded into your lisp environment using
ASDF. Assuming that ASDF is properly installed, and the <small>SHOP3</small>.asd system
definition file can be found by ASDF,, the following command should get
the system loaded:
</p>
<div class="example">
<pre class="example">(asdf:load-system &quot;shop3&quot;)
</pre></div>

<p><small>SHOP3</small> is defined in the <small>SHOP3</small> package (and uses the <small>SHOP3</small>.theorem-prover
package). The easiest way to use the system for experimentation will be
to change to the predefined <code>:SHOP-USER</code> package and work in there:
</p>
<div class="example">
<pre class="example">(in-package :SHOP-USER)
</pre></div>


<p>If you are working on a larger or more ambitious project, it will be
more appropriate for you to work in a package of your own definition,
which should, at least, <code>:use</code> the <code>SHOP3</code> and <code>COMMON-LISP</code> packages.
</p>
<hr>
<span id="Executing-the-Planner"></span><div class="header">
<p>
Next: <a href="#Tracing" accesskey="n" rel="next">Tracing</a>, Previous: <a href="#Loading-the-Planner" accesskey="p" rel="prev">Loading the Planner</a>, Up: <a href="#Running-SHOP3" accesskey="u" rel="up">Running SHOP3</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Executing-the-Planner-1"></span><h3 class="section">3.2 Executing the Planner</h3>
<span id="g_t_0023executing_002dthe_002dplanner"></span>



<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#find_002dplans" accesskey="1"><code>find-plans</code></a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#find_002dplans_002dstack" accesskey="2">find-plans-stack</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#do_002dproblems" accesskey="3"><code>do-problems</code></a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Common-Keyword-Arguments" accesskey="4">Common Keyword Arguments</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr>
<span id="find_002dplans"></span><div class="header">
<p>
Next: <a href="#find_002dplans_002dstack" accesskey="n" rel="next">find-plans-stack</a>, Previous: <a href="#Executing-the-Planner" accesskey="p" rel="prev">Executing the Planner</a>, Up: <a href="#Executing-the-Planner" accesskey="u" rel="up">Executing the Planner</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="FIND_002dPLANS"></span><h4 class="subsection">3.2.1 <code>FIND-PLANS</code></h4>
<p>The find-plans function has one mandatory argument, the name of a
planning problem, and a set of optional keyword arguments. It returns up
to four values. Find-plans will always return two values: (1) a list of
plans and (2) the total amount of CPU time used during planning (in
seconds). If the :plan-tree argument (see below) is non-NIL, then two
additional values will be returned: (3) a list of plan tree data
structures and (4) a list of final state data structures. From the plan
state data structures, the user can extract full state trajectories for
the plans.
</p>
<span id="index-find_002dplans"></span>
<span id="Function-find_002dplans"></span><dl>
<dt id="index-find_002dplans-1">Function: <strong>find-plans</strong> <em>problem &amp;key domain which verbose gc pp plan-tree optimize-cost collect-state time-limit explanation depth-cutoff state tasks state-type hand-steer leashed out-stream</em></dt>
<dd><p><code>find-plans</code> looks for solutions to the planning problem named <code>problem</code>.
   The keyword arguments are as follows:
     <code>:which</code> tells what kind of search to do.  Its possible values are:
        <code>:first</code>      <code>-</code> depth-first search, returning the first plan found.
        <code>:all</code>        <code>-</code> depth-first search for *all* plans.
        <code>:shallowest</code> <code>-</code> depth-first search for the shallowest plan in the
                      search space (this usually is also the shortest plan).
                      If there&rsquo;s more than one such plan, return the first.
</p>
<dl compact="compact">
<dt><em><code>:all-shallowest</code> <code>-</code> depth-first search for all shallowest plans.</em></dt>
<dt><em><code>:id-first</code>   <code>-</code> iterative deepening search, returning the first plan.</em></dt>
<dt><em><code>:id-all</code>     <code>-</code> iterative deepening search for all shallowest plans.</em></dt>
<dt><em><code>:random</code>     <code>-</code> Randomized search.  Used by Monroe. Not for normal</em></dt>
<dd><p>SHOP2 domains, since normal SHOP2 domains have order-
                      dependent semantics.
</p></dd>
</dl>


<dl compact="compact">
<dt><em><code>:verbose</code> says how much information to print about the plans SHOP2</em></dt>
<dd><p>finds.  Its values can be any of the following:
        0 or <code>nil</code>    <code>-</code> print nothing
        1 or <code>:stats</code> <code>-</code> print some statistics on SHOP2&rsquo;s operation
        2 or <code>:plans</code> <code>-</code> print the stats and print all plans found, but omit
             operator costs and omit all operators whose names start with &quot;!!&quot;
        3 or <code>:long-plans</code> <code>-</code> print the stats and plans, including all operator
             costs and all operators (even those whose names start with &quot;!!&quot;)
</p>
</dd>
<dt><em><code>:gc</code> says whether to do a garbage collection before calling <code>seek-plans</code></em></dt>
<dt><em><code>:plan-tree</code> indicates whether or not to return plan tree(s).</em></dt>
<dt><em><code>:collect-state</code> indicates whether or not to return final state(s).  For backward-</em></dt>
<dd><p>compatibility, states are also returned whenever <code>:plan-tree</code> is true.
             This should probably eventually change.
</p></dd>
</dl>


<dl compact="compact">
<dt><em><code>return</code> <code>values:</code></em></dt>
<dd><p><code>plans</code> <code>found</code> <code>---</code> a list of plans.  Each plan is a list that alternates a
                     between instantiated operators and costs
     <code>run</code> <code>time</code> <code>---</code> floating point value in seconds
       /if/ the <code>plan-tree</code> keyword argument is supplied, there will be two
       additional return values:
     <code>plan-trees</code> <code>---</code> a list of plan trees, whose form is specified elsewhere.
     <code>final-states</code> <code>---</code> a list of final state structures, one per plan.
</p></dd>
</dl>

</dd></dl>

<hr>
<span id="find_002dplans_002dstack"></span><div class="header">
<p>
Next: <a href="#do_002dproblems" accesskey="n" rel="next">do-problems</a>, Previous: <a href="#find_002dplans" accesskey="p" rel="prev">find-plans</a>, Up: <a href="#Executing-the-Planner" accesskey="u" rel="up">Executing the Planner</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="FIND_002dPLANS_002dSTACK"></span><h4 class="subsection">3.2.2 <code>FIND-PLANS-STACK</code></h4>

<span id="index-find_002dplans_002dstack"></span>
<span id="Function-find_002dplans_002dstack"></span><dl>
<dt id="index-find_002dplans_002dstack-1">Function: <strong>find-plans-stack</strong> <em>problem &amp;key domain verbose plan-tree gc no-dependencies repairable rationale out-stream which</em></dt>
<dd><p>Top level search function for explicit-state search in SHOP3.
Does not support the full range of options supported by SHOP3: only
supports finding the first solution to <code>problem</code>.  To comply with SHOP3,
though, always returns a list of plans.
  If the <code>plan-tree</code> keyword argument is non-NIL, will return an enhanced plan
tree, with causal links, unless <code>no-dependencies</code> is non-NIL.
</p></dd></dl>

<hr>
<span id="do_002dproblems"></span><div class="header">
<p>
Next: <a href="#Common-Keyword-Arguments" accesskey="n" rel="next">Common Keyword Arguments</a>, Previous: <a href="#find_002dplans_002dstack" accesskey="p" rel="prev">find-plans-stack</a>, Up: <a href="#Executing-the-Planner" accesskey="u" rel="up">Executing the Planner</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="DO_002dPROBLEMS"></span><h4 class="subsection">3.2.3 <code>DO-PROBLEMS</code></h4>

<p>The <code>do-problems</code> function has one mandatory argument, which can either be
the name of a planning problem set or a list of names of planning
problems. It executes <code> find-plans</code> on each of the given planning problems
and returns <code>nil</code>. 
</p>
<span id="index-do_002dproblems"></span>
<span id="Function-do_002dproblems"></span><dl>
<dt id="index-do_002dproblems-1">Function: <strong>do-problems</strong> <em>problems &amp;rest keywords</em></dt>
<dd><p><code>do-problems</code> runs <code>find-plans</code> on each problem in <code>problems</code>, which may be
either a problem-set name (a symbol) or a list of problems.
</p>
<p>Returns nothing of interest: should only be run for what it displays on the
console.
</p></dd></dl>

<hr>
<span id="Common-Keyword-Arguments"></span><div class="header">
<p>
Previous: <a href="#do_002dproblems" accesskey="p" rel="prev">do-problems</a>, Up: <a href="#Executing-the-Planner" accesskey="u" rel="up">Executing the Planner</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Common-Keyword-Arguments-1"></span><h4 class="subsection">3.2.4 Common Keyword Arguments</h4>

<p>The keyword arguments to find-plans and do-problems are as follows:
</p>
<ul>
<li> <var>which</var> says what kind of search to do. Here are its possible
values and what they mean. The default value of <var>which</var> is the
value of the global variable <code>*which*</code> (whose default value is
<code>:first</code>).
<span id="index-_002awhich_002a"></span>

<table>
<tr><td><strong>Value </strong></td><td><strong>Kind of search </strong></td></tr>
<tr><td>:first</td><td>Depth first search, stopping at the first plan found</td></tr>
<tr><td>:all</td><td>Depth-first search, but don&rsquo;t stop until all plans in
 <i>plans(S, T, M)</i> have been found</td></tr>
<tr><td>:shallowest</td><td>Depth-first search for the shallowest plan (or the first such plan
if there is more than one of them). In many domains, this is also the
least-cost plan</td></tr>
<tr><td>:all-shallowest</td><td>Depth-first search for all shallowest plans in the search space</td></tr>
<tr><td>:id-first</td><td>Iterative-deepening search, stopping after the first plan found</td></tr>
<tr><td>:id-all</td><td>Iterative-deepening search for all shallowest plans</td></tr>
</table>

<p>The <em>iterative deepening</em> options, <code>:id-all</code> and <code>:id-first</code>, are equivalent to taking a modified
version of <code>find-plans</code>
 that backtracks each time it reaches depth
<em>d</em>, and calling it repeatedly with <em>d</em> = 1, 2, ..., until a
plan is found.
</p>
</li><li> <var>verbose</var> says what information to print out, as shown in the
following table. The default value for <var>verbose</var> is 1.
<span id="g_t_0023verbose"></span>
<table>
<tr><td><strong>Value </strong></td><td><strong>What to print </strong></td></tr>
<tr><td>0 or <code>nil</code></td><td>Nothing</td></tr>
<tr><td>1 or <code>:stats</code></td><td>Some statistics about the search</td></tr>
<tr><td>2 or <code>:plans</code></td><td>The statistics plus a succinct version of each plan found:
internal operators 
(see <a href="#g_t_0023internal_002doperators">internal operators</a>),
and operator costs are omitted).</td></tr>
<tr><td>3 or <code>:long-plans</code></td><td>The statistics plus the complete version of each plan found</td></tr>
</table>

</li><li> If
<var>gc</var> is non-nil, then <code>find-plans</code> calls the garbage collector
just before starting its search, thus making it somewhat easier to get
repeatable experimental results. The
default value of <var>gc</var> is <code>T</code>.

</li><li> If <var>pp</var> is non-nil, then all printing done by <small>SHOP3</small> is performed
using the Common Lisp pretty-printing mechanism. This typically leads to
more easily read output. The default value of <var>pp</var> is <code>T</code>.

</li><li> The <var>state</var> argument controls how states are represented
internally. <small>SHOP3</small> can have different performance characteristics
depending on the value provided to this augment. If you are encountering
out-of-memory errors in <small>SHOP3</small> or you want to get the maximum speed
possible from <small>SHOP3</small> for a particular set of problems, you may wish to
experiment with different values for this argument. The default value is
:mixed, which represents states using a combination of lists and hash
tables; this value has been shown to provide a reasonably good
combination of speed and memory usage on a variety of test problems. The
other values are <code>:list</code>, <code>:hash</code>, and <code>:bit</code>.

</li><li> The <var>optimize-cost</var> argument is used to perform planning with
branch-and-bound optimization of the total plan cost. The default value
for this argument is nil. If the value of this argument is nil, the
optimization feature is disabled. If the value of the argument is t,
<small>SHOP3</small> will search for plans with the minimum total cost. If the value of
the argument is a number, <small>SHOP3</small> will use the branch-and-bound technique
to search for plans with cost less than or equal to the value of the
argument. The optimization feature is written under the assumption that
the costs of operators are always non-negative. If this assumption is
invalid, <small>SHOP3</small> will produce unreliable results (specifically it will
prune out some valid plans). The interaction of :optimize-cost with the
various options for :which can be subtle. Below are notes on each
possible combination:

</li><li> <code>(:which :first :optimize-cost t)</code>

<p>Under these arguments, <small>SHOP3</small> returns the first plan found for which no
other valid plan has a lower total cost. Note that this option may take
much more time to run than using (:which :first :optimize-cost nil)
since even after it finds the plan, it must keep searching to see if it
can find a cheaper plan. However, this option may be significantly
faster than <code>(:which :all :optimize-cost nil)</code> since the branch-and-bound
mechanism will prune out non-optimal plans without having to consider
them all the way to the end. In some cases, this will mean that (:which
:first :optimize-cost t) terminates and (:which :all :optimize-cost nil)
does not.
</p>
</li><li> <code>(:which :first :optimize-cost <var>number</var>)</code>

<p>Under these arguments, <small>SHOP3</small> returns the first plan found whose total
cost is less than or equal to the number given. If there is no plan
whose total cost is less than or equal to that number, <small>SHOP3</small> will return
no plans. Note that if the number given is large enough, these arguments
can produce results much more quickly than with (:which :first
:optimize-cost t); specifically, as soon as <small>SHOP3</small> finds a plan for which
the cost is met, it can terminate and does not have to keep searching
for cheaper plans.
</p>
</li><li> <code>(:which :all :optimize-cost t)</code>

<p>Under these arguments, <small>SHOP3</small> returns all plans for which no other valid
plan has a lower total cost. Obviously, all plans returned under these
options will have equal total cost.
</p>
</li><li> <code>(:which :all :optimize-cost <var>number</var>)</code>

<p>Under these arguments, <small>SHOP3</small> returns all plans with total cost less than
or equal to the given number.
</p>
</li><li> <code>(:which :shallowest :optimize-cost t)</code>

<p>Under these arguments, <small>SHOP3</small> returns a plan that has the shallowest
depth of all valid plans and for which there is no other shallowest
depth valid plan which has a lower total cost. In other words, these
arguments produce the cheapest of all shallowest plans (which,
incidentally, is not necessarily the same thing as the shallowest of all
cheapest plans).
</p>
</li><li> <code>(:which :shallowest :optimize-cost <var>number</var>)</code>

<p>Under these arguments, <small>SHOP3</small> returns a plan which has the shallowest
depth of all valid plans and whose total cost is less than or equal to
the given number. Note that if there is no plan whose cost is less than
or equal to the number and whose depth is shallowest among all valid
plans, then no plan will be returned (even if there are deeper plans
which do have cost less than or equal to the number).
</p>
</li><li> <code>(:which :all-shallowest :optimize-cost t)</code>

<p>Under these arguments, <small>SHOP3</small> returns all plans which have the shallowest
depth of all valid plans and for which there is no other shallowest
depth valid plan which has a lower total cost.
</p>
</li><li> <code>(:which :all-shallowest :optimize-cost <var>number</var>)</code>

<p>Under these arguments, <small>SHOP3</small> returns all plans which have the shallowest
depth and whose total cost is less than or equal to the given number.
</p>
</li><li> <code>(:which :id-first)</code> or <code>(:which :id-all)</code>

<p>The <code>:id-first</code> and <code>:id-all</code> options produce the same results
as the <em>shallowest</em> and <em>all-shallowest</em> arguments,
respectively for each different combination with <code>:optimize-cost</code>. Note,
however, that there are domains for which <small>SHOP3</small> will terminate using
<em>id-first</em> and <em>id-all</em> and will not terminate using other
values for <code>:which</code>.
</p>
</li><li> The <var>time-limit</var> argument may either nil or a number. Its default
is nil and if it is nil, no time limit is imposed on the planning
process. If the <var>time-limit</var> argument is a number, <small>SHOP3</small> will check
the elapsed CPU time at the start of each step of the planning process,
and if the number of seconds elapsed is greater than the argument value,
<small>SHOP3</small> will immediately terminate. The main use for this feature is in
combination with (:optimize-cost t) argument, in order to return the
optimal value found within the given time limit. For example, consider
the call <code>(find-plans 'foo :verbose 1 :optimize-cost t :time-limit 120)</code>.
This call addresses a problem named <em>foo</em>, and runs until it either
finds the minimum cost plan or until 2 minutes have elapsed. It then
returns the lowest cost plan that it found during that time. This
functionality is inspired, in part, by Anytime Algorithms [Dean and
Boddy, 1998].

</li><li> <span id="g_t_0023explanation"></span>If <em>explanation</em> is non-nil, <small>SHOP3</small> adds extra information at the
end of each operator explaining how the preconditions for that operator
were satisfied. Currently supports only logical atoms, and, and or; it
doesn&rsquo;t work with forall, not, eval, etc. If this feature is used with
the external-access-hook feature (see Section 5.4), any attribution
information provided by the external-access-hook routine is included in
the relevant explanation. The default value of <em>explanation</em> is
<code>nil</code>. 
<span id="index-explanation"></span>

</li><li> The <em>plan-tree</em> argument defaults to nil; if true, the planner will
return two additional values: (1) a list of complete task decomposition
trees for the plans and (2) a list of plan state data structures
corresponding to the final states of each plan. Plan trees are encoded
in a nested list format in which the decomposition of an upper level
task into lower level tasks is represented by the upper level task atom,
followed by trees for each lower level task. The leaves of the tree,
involving operators, are each lists of three elements: the cost of the
operator, the task atom for the operator, and the numerical position of
the operator in the plan (staring at 1). For example, a task (travel
houston springfield) that was directly decomposed into operators, (!fly
houston boston) with cost 200 and (!drive boston springfield) with cost
50, would have the following plan tree:

<div class="lisp">
<pre class="lisp">((travel houston springfield)
 (200 (!fly houston boston) 1)
 (50 (!drive boston springfield) 2))
</pre></div>

</li></ul>


<hr>
<span id="Tracing"></span><div class="header">
<p>
Next: <a href="#Other-Debugging-Features" accesskey="n" rel="next">Other Debugging Features</a>, Previous: <a href="#Executing-the-Planner" accesskey="p" rel="prev">Executing the Planner</a>, Up: <a href="#Running-SHOP3" accesskey="u" rel="up">Running SHOP3</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Tracing-1"></span><h3 class="section">3.3 Tracing</h3>
<span id="index-shop_002dtrace"></span>
<span id="index-shop_002duntrace"></span>
<p>There are two functions used for controlling the tracing mechanism in
<small>SHOP3</small>: <code>shop-trace</code> and <code>shop-untrace</code>. These are similar to Lisp&rsquo;s trace
and untrace functions. Once they have been invoked, subsequent calls to
<code>find-plans</code> or <code>do-problems</code> will print out information about elements of
the domain for which tracing is enabled whenever those elements are
encountered. More specifically:
</p>
<ul>
<li> <code>(shop-trace <var>item</var>)</code>
will turn on tracing for <var>item</var>, which may be any
of the following:
<ul>
<li> a method, axiom, operator, task, or goal;
</li><li> one of the keywords <code>:methods</code>, <code>:axioms</code>, <code>:operators</code>, <code>:tasks</code>, <code>:goals</code>, or
<code>:protections</code> in which case <small>SHOP3</small> will trace <em>all</em> items of that type
(<code>:goals</code> refers to predicates that are goals for the theorem-prover, and
<code>:protections</code> refers to predicates used as arguments of <code>:protection</code> in
operators);
</li><li> the keyword <code>:states</code>, in which case <small>SHOP3</small> will include the current state
whenever it prints out a tracing message
</li><li> the keyword <code>:plans</code> in which case <small>SHOP3</small> will print diagnostic information
whenever it has found a plan (and may be considering whether or not to
keep the plan, depending on the :which and :optimize arguments of
seek-plans).
</li><li> The keyword <code>:all</code>, which will trace all available items, currently
methods, axioms, operators, tasks, goals and protections.
</li></ul>

</li><li> <code>(shop-trace <em>item1 item2</em> ...)</code>
 will do the same for a list of items
</li><li> <code>(shop-trace)</code> will print a list of what&rsquo;s currently being traced
</li><li> <code>(shop-untrace <em>item</em>)</code> will turn off tracing for an item
</li><li> <code>(shop-untrace <em>item1 item2</em> ...)</code> will turn off tracing for a list
of items
</li><li> <code>(shop-untrace)</code> will turn off tracing for all items
</li></ul>

<span id="index-shop_002dtrace-1"></span>
<span id="Macro-shop_002dtrace"></span><dl>
<dt id="index-shop_002dtrace-2">Macro: <strong>shop-trace</strong> <em>&amp;rest items</em></dt>
<dd><p><code>-</code> <code>(shop-trace) </code>with no arguments will return a list of what&rsquo;s
currently being traced.
</p>
<p><code>-</code> <code>(shop-trace item) </code>will turn on tracing for <code>item</code>.
</p>
<p><code>item</code> may be any of the following:
</p> 
<ul>
<li> the name of a method, axiom, operator, task, or predicate;
</li><li> one of the keywords <code>:methods</code>, <code>:axioms</code>, <code>:operators</code>, <code>:tasks</code>,
      <code>:goals</code>, <code>:effects</code>, or <code>:protections</code>, in which case <code>shop</code> will
      trace all items of that type (:GOALS, <code>:effects</code>, and <code>:protections</code>
      refer to three different ways predicates can occur: as goals to
      be satisfied, and as effects or protections in operators);
</li><li> a pair of the form <code>(:task &lt;taskname&gt;)</code>, <code>(:method &lt;methodname&gt;)</code>.  <code>shop</code> will
      break when attempting to expand the task, or apply the method, respectively.
</li><li> the keyword <code>:states</code>, in which case <code>shop</code> will include the current
      state whenever it prints out a tracing message
</li><li> the keyword <code>:all</code> in which case <code>shop</code> will print out all the tracing
      information it knows how to.

</li></ul>
<p><code>-</code> <code>(shop-trace item1 item2 ...) </code>will do the same for a list of items
</p></dd></dl>

<hr>
<span id="Other-Debugging-Features"></span><div class="header">
<p>
Next: <a href="#Syntax-Checks" accesskey="n" rel="next">Syntax Checks</a>, Previous: <a href="#Tracing" accesskey="p" rel="prev">Tracing</a>, Up: <a href="#Running-SHOP3" accesskey="u" rel="up">Running SHOP3</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Other-Debugging-Features-1"></span><h3 class="section">3.4 Other Debugging Features</h3>
<span id="index-_002acurrent_002dstate_002a"></span>
<span id="index-_002acurrent_002dplan_002a"></span>
<span id="index-_002acurrent_002dtasks_002a"></span>
<span id="index-_002abreak_002don_002dbacktrack_002a"></span>
<span id="index-print_002dcurrent_002dstate"></span>
<span id="index-print_002dcurrent_002dplan"></span>
<span id="index-print_002dcurrent_002dtasks"></span>

<p>There are three variables, namely <code>*current-state*</code>, <code>*current-plan*</code>, and
<code>*current-tasks*</code>, in <small>SHOP3</small>. These variables can be used to monitor the
current status of the state, current plan and the list of current tasks
to be accomplished respectively. Since these are the internal variables
</p>
<p>of the <small>SHOP3</small> planning system, the following functions are defined to
access the current contents of those variables: <code>print-current-state</code>,
<code>print-current-plan</code>, and <code>print-current-tasks</code>, respectively. Note that
these are Lisp functions that must be called by using the Lisp
evaluator. The best way to use these functions is to define dedicated
methods in the domain that invoke the functions using eval or call
expressions in their predicates. Those methods can then be used in the
problem definition where debugging output is needed. For example, the
following methods can be included in any domain description for this
purpose:
</p>
<div class="lisp">
<pre class="lisp">(:method (print-current-state)
    ((eval (print-current-state)))
    ())

(:method (print-current-tasks)
   ((eval (print-current-tasks)))
   ())

(:method (print-current-plan)
    ((eval (print-current-plan)))
    ())
</pre></div>


<p>And these special purpose methods can be used in the task decompositions
of other methods for debugging purposes. For example,
</p>
<div class="lisp">
<pre class="lisp">(:method
    (do-both ?x ?y)
    nil
    (:ordered
      (:task !do ?y)
      (:task print-current-state)
      (:task !do ?x))))
</pre></div>

<p>There is now a new variable, <var>*break-on-backtrack*</var>, that will cause the
Lisp environment to throw into a break loop when <small>SHOP3</small> backtracks.
</p>
<hr>
<span id="Syntax-Checks"></span><div class="header">
<p>
Next: <a href="#Debugging-Suggestions" accesskey="n" rel="next">Debugging Suggestions</a>, Previous: <a href="#Other-Debugging-Features" accesskey="p" rel="prev">Other Debugging Features</a>, Up: <a href="#Running-SHOP3" accesskey="u" rel="up">Running SHOP3</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Syntax-Checks-1"></span><h3 class="section">3.5 Syntax Checks</h3>

<span id="index-singleton-variables"></span>
<span id="index-anonymous-variables"></span>

<p>We have adopted for <small>SHOP3</small> the âsingleton variableâ check common in
Prolog implementations. Logic variables are used to express unification
constraints on expressions. In practice, a singleton logical variable in
a <small>SHOP3</small> expression (a method, operator, or axiom definition) is often a
typographical error. Accordingly, <small>SHOP3</small> will issue a warning when it
encounters a logical variable used only once. If the single use is
correct, the proper (and nicely self-documenting) way to disable this
warning is to use an <em>anonymous variable</em> (see see <a href="#Symbols">Symbols</a>).
</p>
<hr>
<span id="Debugging-Suggestions"></span><div class="header">
<p>
Next: <a href="#Hook-Routines" accesskey="n" rel="next">Hook Routines</a>, Previous: <a href="#Syntax-Checks" accesskey="p" rel="prev">Syntax Checks</a>, Up: <a href="#Running-SHOP3" accesskey="u" rel="up">Running SHOP3</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Debugging-Suggestions-1"></span><h3 class="section">3.6 Debugging Suggestions</h3>
<span id="g_t_0023debugging_002dsuggestions"></span><p>When you have a problem that does not solve as expected, the following
general recipe may help you home in on bugs in your domain definition:
</p>
<ol>
<li> Start by doing <code>(SHOP-TRACE :TASKS)</code> and then try <code>FIND-PLANS</code> again.

</li><li> In many cases, the domain will be written so that there will be little
or no backtracking. In this case, examine the output of the traced call
to <code>FIND-PLANS</code> and look for the first backtracking point.

</li><li> The above process should help you identify a particular task, either a
primitive or a complex task, as a likely problem spot. If it&rsquo;s a
primitive task, the next step is to examine the operator definition. If
it&rsquo;s a complex task, you should check the method definitions. If you
have any trouble identifying which method definition is relevant, you
can use <code>(SHOP-TRACE :METHODS)</code> to further focus your attention.

</li><li> If visual inspection of method and operator definitions does not reveal
the problem, you most likely have problems with precondition
expressions. In this case, try using <code>(SHOP-TRACE :GOALS)</code>, rerunning
<code>FIND-PLANS</code> and check to see what&rsquo;s happened when your problematic method or
operator&rsquo;s preconditions are checked.

</li></ol>

<p>This recipe has proven effective for finding the vast majority of bugs
in <small>SHOP3</small> domains.
</p>
<hr>
<span id="Hook-Routines"></span><div class="header">
<p>
Previous: <a href="#Debugging-Suggestions" accesskey="p" rel="prev">Debugging Suggestions</a>, Up: <a href="#Running-SHOP3" accesskey="u" rel="up">Running SHOP3</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Hook-Routines-1"></span><h3 class="section">3.7 Hook Routines</h3>
<span id="index-hook_002droutines"></span>
<p><small>SHOP3</small> recognizes several different hook routines. These are Lisp
routines that may be defined by the user; if they are defined, they are
invoked under specific circumstances. Hook routines are typically used
when embedding <small>SHOP3</small> in an application; they allow such an application
to obtain additional information from <small>SHOP3</small> or to affect it&rsquo;s behavior.
There are three hooks that are recognized by <small>SHOP3</small>:
</p>
<ul>
<li> <code>(plan-found-hook state which plan cost depth)</code> 
<span id="index-plan_002dfound_002dhook"></span>
If this routine is defined, <small>SHOP3</small> invokes it whenever it finds a plan.
It can be useful for displaying and/or recording details about the plan.
The arguments are the current state, the value for the :which argument
that was provided to the planner, the plan, the cost of the plan, and
the search depth at which the plan was found.
</li><li> <code>(trace-query-hook type item additional-information state-atoms)</code>
<span id="index-trace_002dquery_002dhook"></span>
If this routine is defined, <small>SHOP3</small> invokes it whenever it invokes the
tracing mechanism (see <a href="#Tracing">Tracing</a>). The arguments include the type of
item being traced (e.g., <code>:task</code>, <code>:method</code>), the item, the list of Lisp
values that are printed by the tracing mechanism, and a list of logical
atoms in the current state.
</li><li> <code>(external-access-hook query)</code>
<span id="index-external_002daccess_002dhook"></span>
This hook routine is intended to allow <small>SHOP3</small> to use an external source
(such as a database) to determine the applicability of methods and
operators. To use this hook routine, a domain must include one or more
logical expressions that have the keyword :external as the first symbol.
Such expressions must only involve a single logical atom, or a single
conjunction of logical atoms. When <small>SHOP3</small> attempts to find a binding that
satisfies such an expression, it will first invoke external-access-hook
to satisfy the expression; if that routine is undefined or returns nil,
<small>SHOP3</small> will then try to satisfy the expression using its internal
knowledge state. The argument to external-access-hook is a list of the
form <code>'(and (<var>pred</var> <var>val</var> <var>val</var>)...)</code>. It returns a list of responses,
each of which is a list of two elements: an attribution and a list of
bindings for the unbound variables in the query. The attribution is
stored for use with the <em>explanation</em> option for the planning
system (see <a href="#g_t_0023explanation">explanation</a>). For example, consider a method that has the
following precondition:

<div class="lisp">
<pre class="lisp">(or (and (clear ?b1)
             (clear ?b2)
             (clear ?b3))
     (:external and (on ?b1 ?b2) (on ?b2 ?b3)))
</pre></div>

<p>When this precondition is encountered and external-access-hook is
defined, <small>SHOP3</small> invokes that routine with the argument <code>'(and (on ?b1 ?b2)
(on ?b2 ?b3))</code>. The routine might (for example) return the list:
</p>
<div class="lisp">
<pre class="lisp">'((database-123 ((?b1 block10) (?b2 block 11) (?b3 block 12)))
  (database-223 ((?b1 block20) (?b2 block 21) (?b3 block 22))))
</pre></div>
</li></ul>



<hr>
<span id="The-SHOP3-Formalism"></span><div class="header">
<p>
Next: <a href="#PDDL-Support" accesskey="n" rel="next">PDDL Support</a>, Previous: <a href="#Running-SHOP3" accesskey="p" rel="prev">Running SHOP3</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="The-SHOP3-Formalism-1"></span><h2 class="chapter">4 The <small>SHOP3</small> Formalism</h2>
<p>The inputs to <small>SHOP3</small> are a <em>planning domain</em> and either a single
<em>planning problem</em> or a <em>planning problem set</em>. Planning
domains are composed of <em>operators</em>, <em>methods</em>, and
<em>axioms</em>. Planning problems are composed of <em>logical atoms</em>
(an initial state) and <em>tasks lists</em> (high-level actions to
perform). Planning problem sets are composed of planning problems.
</p>
<p>The components of a planning domain (operators, methods, and axioms) all
involve <em>logical expressions</em>. These logical expressions combine
<em>logical atoms</em> through a variety of forms (e.g., conjunction,
disjunction). Logical atoms involve a <em>predicate symbol</em> plus a
list of <em>terms</em>. Task lists in planning problems are composed of
<em>task atoms</em>. The components of domains and problems are all
ultimately defined by various <em>symbols</em>.
</p>
<p>This section describes each of the aforementioned structures. It is
organized in a bottom-up manner because the specification of
higher-level structures is dependent on the specification of lower-level
structures. For example, methods are defined after logical expressions
because methods contain logical expressions.
</p><table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#Symbols" accesskey="1">Symbols</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#General-Lisp-Expressions" accesskey="2">General Lisp Expressions</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Terms" accesskey="3">Terms</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Logical-Atoms" accesskey="4">Logical Atoms </a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Logical-Expressions" accesskey="5">Logical Expressions</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Logical-Precondition" accesskey="6">Logical Precondition</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Axioms" accesskey="7">Axioms</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Task-Atoms" accesskey="8">Task Atoms</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Task-Lists" accesskey="9">Task Lists</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Operators">Operators</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Methods">Methods</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Planning-Domain">Planning Domain</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Planning-Problem">Planning Problem</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Planning-Problem-Set">Planning Problem Set</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Plans">Plans</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr>
<span id="Symbols"></span><div class="header">
<p>
Next: <a href="#General-Lisp-Expressions" accesskey="n" rel="next">General Lisp Expressions</a>, Previous: <a href="#The-SHOP3-Formalism" accesskey="p" rel="prev">The SHOP3 Formalism</a>, Up: <a href="#The-SHOP3-Formalism" accesskey="u" rel="up">The SHOP3 Formalism</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Symbols-1"></span><h3 class="section">4.1 Symbols</h3>
<span id="g_t_0023symbols"></span><p>In the structures defined below, there are five kinds of symbols:
<strong>variable symbols</strong>, <strong>constant symbols</strong>, <strong>function
symbols</strong>, <strong>primitive task symbols</strong>, and <strong>compound task
symbols</strong>. To distinguish among these symbols, SHOP and <small>SHOP3</small> both use
the following conventions:
</p>
<ul>
<li> a <strong>variable symbol</strong> can be any Lisp symbol whose name begins with
a question mark (such as ?x or ?hello-there)

</li><li> an <strong>anonymous variable symbol</strong> can be any variable symbol with an
underscore immediately following the question mark in its name (such as
?_ or ?_airplane). These variables will unify with any value, and need
not co-refer (i.e., two copies of ?_ in a single term need not unify
with each other). These variables will also not trip the singleton
variable check.

</li><li> a <strong>primitive task symbol</strong> can be any Lisp symbol whose name
begins with an exclamation point (such as !unstack or !putdown)

</li><li> a <strong>constant</strong> <strong>symbol</strong>, a <strong>function symbol</strong>, a
<strong>predicate symbol</strong>, or a <strong>compound task symbol</strong> can be any
Lisp symbol whose name does not begin with a question mark or
exclamation point

</li></ul>

<p>Any of the structures defined in the remaining sections are said to be
<strong>ground</strong> if they contain no variable symbols.
</p>
<hr>
<span id="General-Lisp-Expressions"></span><div class="header">
<p>
Next: <a href="#Terms" accesskey="n" rel="next">Terms</a>, Previous: <a href="#Symbols" accesskey="p" rel="prev">Symbols</a>, Up: <a href="#The-SHOP3-Formalism" accesskey="u" rel="up">The SHOP3 Formalism</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="General-Lisp-Expressions-1"></span><h3 class="section">4.2 General Lisp Expressions</h3>
<span id="g_t_0023general_002dlisp_002dexpressions"></span><p>A number of <small>SHOP3</small> domain structures described in this section use
<strong>general Lisp expressions</strong>. These are arbitrary pieces of Lisp
code which can include functions, macros, special macro symbols (e.g.,
backquote), etc. When <small>SHOP3</small> needs to get the value of a general Lisp
expression, it first substitutes values for any variable symbols in the
expression that are bound. Then it sends the entire expression into the
Lisp evaluator to get a final value.
</p>
<p><strong>Note:</strong> Counter-intuitive bugs may arise when symbols are passed
to lisp for evaluation (either as constants or as the values of
variables). Remember that the lisp evaluator will assume that these are
variables! If you wish them to be treated as symbols, you will need to
quote them. This leads to a slightly undesirable oddity &mdash; variables
that will be bound to, for example, numbers, can appear normally.
Variables that will be bound to symbols will have to be quoted. See the
discussion of Eval terms, below (Section 4.3.2).
</p>
<hr>
<span id="Terms"></span><div class="header">
<p>
Next: <a href="#Logical-Atoms" accesskey="n" rel="next">Logical Atoms</a>, Previous: <a href="#General-Lisp-Expressions" accesskey="p" rel="prev">General Lisp Expressions</a>, Up: <a href="#The-SHOP3-Formalism" accesskey="u" rel="up">The SHOP3 Formalism</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Terms-1"></span><h3 class="section">4.3 Terms</h3>
<span id="g_t_0023terms"></span><p>A <strong>term</strong> is any one of the following:
</p>
<ul>
<li> a variable symbol

</li><li> a constant symbol

</li><li> a number

</li><li> a <strong>list-term</strong>

</li><li> an <strong>eval-term</strong>

</li><li> a <strong>call-term</strong>

</li></ul>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#List-Terms" accesskey="1">List Terms</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Eval-Terms" accesskey="2">Eval Terms</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Call_002dterms" accesskey="3">Call-terms</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr>
<span id="List-Terms"></span><div class="header">
<p>
Next: <a href="#Eval-Terms" accesskey="n" rel="next">Eval Terms</a>, Previous: <a href="#Terms" accesskey="p" rel="prev">Terms</a>, Up: <a href="#Terms" accesskey="u" rel="up">Terms</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="List-Terms-1"></span><h4 class="subsection">4.3.1 List Terms</h4>
<span id="g_t_0023list_002dterms"></span><p>A <strong>list-term</strong> is a term having the form
</p>
<div class="lisp">
<pre class="lisp">([list] <em>t<sub>1</sub></em> <em>t<sub>2</sub></em> ... <em>t<sub>n</sub> [. l]</em>)
</pre></div>
<p>where <em>list</em> is an optional reserved word and each <em>t<sub>i</sub></em>
is a term. This specifies that <em>t<sub>1</sub></em> <em>t<sub>2</sub></em> ...
<em>t<sub>n </sub></em>are the items of a list. If the final, optional element
is included, the item <em>l</em> should evaluate to a list; all items in
<em>l</em> are included in the list after <em>t<sub>1</sub></em> through
<em>t<sub>n</sub></em>.
</p>
<hr>
<span id="Eval-Terms"></span><div class="header">
<p>
Next: <a href="#Call_002dterms" accesskey="n" rel="next">Call-terms</a>, Previous: <a href="#List-Terms" accesskey="p" rel="prev">List Terms</a>, Up: <a href="#Terms" accesskey="u" rel="up">Terms</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Eval-Terms-1"></span><h4 class="subsection">4.3.2 Eval Terms</h4>
<span id="g_t_0023eval_002dterms"></span><p>An <strong>eval-term</strong> is an expression of the form
</p>
<div class="lisp">
<pre class="lisp">(eval <em>general</em>-<em>lisp-expression</em>)
</pre></div>
<p>The value associated with an eval-term is determined as follows. First,
any variable symbols which appear in <em>lisp-expression</em> and are
bound are replaced by the values that they are bound to. Then, the
entire expression is evaluated in Lisp. For example, if the variable
symbol ?foo is bound to the value 3 then the term:
</p>
<div class="lisp">
<pre class="lisp">(eval (mapcar #'(lambda (x) (+ x ?foo)) `(1 2 ,(* ?foo ?foo))))
</pre></div>

<p>will have as its value a list containing the numbers 4, 5, and 12. Note
that variable substitutions in eval terms are handled before any
evaluation of the expression, as in Lisp macros. One implication of this
fact is that variables with symbolic values must be explicitly quoted if
they are to be treated as Lisp symbols. For example, if the variable
<code>?foo</code> is bound to the symbol <code>BAR</code>, the following eval term has the value
<code>(BAR BAZ)</code>:
</p>
<div class="lisp">
<pre class="lisp">(eval (list '?foo 'BAZ))
</pre></div>

<p>if this were written
</p>
<div class="lisp">
<pre class="lisp">(eval (list ?foo 'BAZ))
</pre></div>

<p>it would cause a Lisp error when lisp attempts to find the value of <code>BAR</code>,
which it would believe to be a variable.
</p>
<hr>
<span id="Call_002dterms"></span><div class="header">
<p>
Previous: <a href="#Eval-Terms" accesskey="p" rel="prev">Eval Terms</a>, Up: <a href="#Terms" accesskey="u" rel="up">Terms</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Call_002dterms-1"></span><h4 class="subsection">4.3.3 Call-terms</h4>
<span id="g_t_0023call_002dterms"></span><p>A <strong>call-term</strong> is an expression of the form
</p>
<div class="lisp">
<pre class="lisp">(call f <em>t<sub>1</sub></em> <em>t<sub>2</sub></em> ... <em>t<sub>n</sub></em>)
</pre></div>
<p>where <em>f</em> is a function symbol and each <em>t<sub>i</sub></em> is a term
or a call-term. A call-term has a special meaning to <small>SHOP3</small>, because it
tells <small>SHOP3</small> that <em>f</em> is an attached procedure, i.e., that whenever
<small>SHOP3</small> needs to evaluate a precondition or task list that contains a
call-term, <small>SHOP3</small> should replace the call term with the result of
applying the function <em>f</em> on the arguments <em>t<sub>1</sub>,
t<sub>2</sub>, &hellip;, t<sub>n</sub></em>. (We later will define what preconditions
and task lists are).
</p>
<p>For example, the following call-term would have the value 6:
</p>
<div class="lisp">
<pre class="lisp">(call + (call + 1 2) 3)
</pre></div>
<p>Note that a call-term is not as expressive as an eval-term. In
particular, it does not support the evaluation of Lisp macros (including
macro characters such as backquote). Both call and eval are supported in
<small>SHOP3</small> because the former is compatible with JSHOP 1.0 and the latter is
compatible with SHOP 1.x. <small>SHOP3</small> users who are not interested in either
form of compatibility may use either form.
</p>
<hr>
<span id="Logical-Atoms"></span><div class="header">
<p>
Next: <a href="#Logical-Expressions" accesskey="n" rel="next">Logical Expressions</a>, Previous: <a href="#Terms" accesskey="p" rel="prev">Terms</a>, Up: <a href="#The-SHOP3-Formalism" accesskey="u" rel="up">The SHOP3 Formalism</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Logical-Atoms-1"></span><h3 class="section">4.4 Logical Atoms</h3>
<span id="g_t_0023logical_002datoms"></span><p>A <strong>logical atom</strong> has the form:
</p>
<div class="lisp">
<pre class="lisp">(<em>p</em> <em>t<sub>1</sub></em> <em>t<sub>2</sub></em> ... <em>t<sub>n</sub></em>)
</pre></div>
<p>where <em>p</em> is a predicate symbol and each <em>t<sub>i </sub></em> is a term
other than an eval- or call-term.
</p>
<hr>
<span id="Logical-Expressions"></span><div class="header">
<p>
Next: <a href="#Logical-Precondition" accesskey="n" rel="next">Logical Precondition</a>, Previous: <a href="#Logical-Atoms" accesskey="p" rel="prev">Logical Atoms</a>, Up: <a href="#The-SHOP3-Formalism" accesskey="u" rel="up">The SHOP3 Formalism</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Logical-Expressions-1"></span><h3 class="section">4.5 Logical Expressions</h3>
<span id="g_t_0023logical_002dexpressions"></span><p>A <strong>logical expression</strong> is a logical atom or any of the following
complex expressions: <strong>conjuncts</strong>, <strong>disjuncts</strong>,
<strong>negations</strong>, <strong>implications</strong>, <strong>universal
quantifications</strong>, <strong>assignments</strong>, <strong>eval expressions</strong>,
<strong>call expressions</strong>.
</p><table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#Conjuncts" accesskey="1">Conjuncts</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Disjuncts" accesskey="2">Disjuncts</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Negations" accesskey="3">Negations</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Implications" accesskey="4">Implications</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Universal-Quantifications" accesskey="5">Universal Quantifications</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Assignments" accesskey="6">Assignments</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Eval-expressions" accesskey="7">Eval expressions</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Call_002dexpressions" accesskey="8">Call-expressions</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Enforce_002dexpressions" accesskey="9">Enforce-expressions</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Setof_002dexpressions">Setof-expressions</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Bagof_002dexpressions">Bagof-expressions</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr>
<span id="Conjuncts"></span><div class="header">
<p>
Next: <a href="#Disjuncts" accesskey="n" rel="next">Disjuncts</a>, Previous: <a href="#Logical-Expressions" accesskey="p" rel="prev">Logical Expressions</a>, Up: <a href="#Logical-Expressions" accesskey="u" rel="up">Logical Expressions</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Conjuncts-1"></span><h4 class="subsection">4.5.1 Conjuncts</h4>
<span id="g_t_0023conjuncts"></span><p>A <strong>conjunct</strong> has the form
</p>
<div class="lisp">
<pre class="lisp">([and]<em>l<sub>1</sub></em> <em>l<sub>2</sub></em> ... <em>l<sub>n</sub></em>)
</pre></div>
<p>where each <em>l<sub>i </sub></em> is a logical expression. Note that if there
are 0 conjuncts (e.g., the expression is ()) then the form always
evaluates to true.
</p>
<hr>
<span id="Disjuncts"></span><div class="header">
<p>
Next: <a href="#Negations" accesskey="n" rel="next">Negations</a>, Previous: <a href="#Conjuncts" accesskey="p" rel="prev">Conjuncts</a>, Up: <a href="#Logical-Expressions" accesskey="u" rel="up">Logical Expressions</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Disjuncts-1"></span><h4 class="subsection">4.5.2 Disjuncts</h4>
<span id="g_t_0023disjuncts"></span><p>A <strong>disjunct</strong> is an expression of the form
</p>
<div class="lisp">
<pre class="lisp">(or <em>l<sub>1</sub> l<sub>2</sub> ... l<sub>n</sub></em>)
</pre></div>
<p>where <em>l<sub>1</sub></em>, <em>l<sub>2</sub></em>,..., <em>l<sub>n</sub></em> are logical
expressions.
</p>
<hr>
<span id="Negations"></span><div class="header">
<p>
Next: <a href="#Implications" accesskey="n" rel="next">Implications</a>, Previous: <a href="#Disjuncts" accesskey="p" rel="prev">Disjuncts</a>, Up: <a href="#Logical-Expressions" accesskey="u" rel="up">Logical Expressions</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Negations-1"></span><h4 class="subsection">4.5.3 Negations</h4>
<span id="g_t_0023negations"></span><p>A <strong>negation</strong> is an expression of the form
</p>
<div class="lisp">
<pre class="lisp">(not <em>l</em>)
</pre></div>
<p>where <em>l</em> is a logical expression.
</p>
<hr>
<span id="Implications"></span><div class="header">
<p>
Next: <a href="#Universal-Quantifications" accesskey="n" rel="next">Universal Quantifications</a>, Previous: <a href="#Negations" accesskey="p" rel="prev">Negations</a>, Up: <a href="#Logical-Expressions" accesskey="u" rel="up">Logical Expressions</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Implications-1"></span><h4 class="subsection">4.5.4 Implications</h4>
<span id="g_t_0023implications"></span><p>An <strong>implication</strong> is an expression of the form
</p>
<div class="lisp">
<pre class="lisp">(imply <em>Y Z</em>)
</pre></div>
<p>where <em>Y</em> and <em>Z</em> are logical expressions. The intent of an
implication is to evaluate its logical counterpart; that is, <em>(Â¬Y â¨
Z)</em>. Note that here, <em>Y</em> should be ground, or the semantic of the
implication will be ambiguous.
</p>
<hr>
<span id="Universal-Quantifications"></span><div class="header">
<p>
Next: <a href="#Assignments" accesskey="n" rel="next">Assignments</a>, Previous: <a href="#Implications" accesskey="p" rel="prev">Implications</a>, Up: <a href="#Logical-Expressions" accesskey="u" rel="up">Logical Expressions</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Universal-Quantifications-1"></span><h4 class="subsection">4.5.5 Universal Quantifications</h4>
<span id="g_t_0023universal_002dquantifications"></span><p>A <strong>universal quantification</strong> expression is an expression of the
form
</p>
<div class="lisp">
<pre class="lisp">(forall <em>V E<sub>1</sub> E<sub>2</sub></em>)
</pre></div>
<p>where <em>E<sub>1</sub></em> and <em>E<sub>2</sub></em> are logical expressions, and
<em>V</em> is the list of variables in <em>E<sub>1</sub></em>. To satisfy a
<strong>universal quantification</strong> expression, the following must hold:
for each possible substitution u for variables in <em>V</em>, if
<em>E<sub>1</sub><sup>u</sup></em> is satisfied then <em>E<sub>2</sub><sup>u</sup></em> must
also be satisfied in the current state of the world. Note that this use
of the keyword âforallâ is distinct from its use in add and delete lists
in operators (see Section 4.10); the latter is used to express a set of
effects rather than a logical expression and consequently has a
different syntax.
</p>
<hr>
<span id="Assignments"></span><div class="header">
<p>
Next: <a href="#Eval-expressions" accesskey="n" rel="next">Eval expressions</a>, Previous: <a href="#Universal-Quantifications" accesskey="p" rel="prev">Universal Quantifications</a>, Up: <a href="#Logical-Expressions" accesskey="u" rel="up">Logical Expressions</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Assignments-1"></span><h4 class="subsection">4.5.6 Assignments</h4>
<span id="g_t_0023assignments"></span><p>A simple <strong>assignment</strong> expression has the form
</p>
<div class="lisp">
<pre class="lisp">(assign <em>v</em> <em>e</em>)
</pre></div>

<p>where <em>v</em> is a variable symbol and <em>e</em> is general Lisp
expression. The intent of an assignment expression is to bind the value
of <em>e</em> to the variable symbol <em>v</em>. Variable substitutions in
assignment expressions are done using literal substitutions, as with
eval terms (see Section 4.3.2). For example, if ?foo is bound to the
symbol IF and ?bar is bound to the number 0 then the following
expression will bind the variable ?baz to the list (IF FISH):
</p>
<div class="lisp">
<pre class="lisp">(assign ?baz (?foo (&lt; ?bar 3) (list '?foo 'fish) (/ 8 ?bar)))
</pre></div>

<p>Similarly, if ?foo is bound to LIST and ?bar is bound to 4 then the
expression above will bind ?baz to the list (NIL (LIST FISH) 2).
</p>
<p><small>SHOP3</small> also offers a <strong>compound assignment</strong> expression of this
form:
</p>
<div class="lisp">
<pre class="lisp">(assign* <em>v</em> <em>e</em>)
</pre></div>


<p>As in the simple assign, <em>v</em> is a variable symbol and <em>e</em> is
general Lisp expression. However, for assign*, <em>e</em> should evaluate
to a <em>list</em> of possible values and through backtracking, <small>SHOP3</small>&rsquo;s
theorem-prover will find all solutions with <em>v</em> bound to the
various values of <em>e,</em> in turn.
</p>
<hr>
<span id="Eval-expressions"></span><div class="header">
<p>
Next: <a href="#Call_002dexpressions" accesskey="n" rel="next">Call-expressions</a>, Previous: <a href="#Assignments" accesskey="p" rel="prev">Assignments</a>, Up: <a href="#Logical-Expressions" accesskey="u" rel="up">Logical Expressions</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Eval-expressions-1"></span><h4 class="subsection">4.5.7 Eval expressions</h4>
<span id="g_t_0023eval_002dexpressions"></span><p>An <strong>eval-expression</strong> has the same form as an
<a href="#g_t_0023eval_002dterms">eval-term</a>, q.v. Unlike an eval-term, however, an
eval-expression is interpreted simply as either true or false rather
than having some value which would be used as an argument to a
predicate. Thus eval-expression typically invoke boolean Lisp functions
such as evenp or &gt;=.
</p>
<hr>
<span id="Call_002dexpressions"></span><div class="header">
<p>
Next: <a href="#Enforce_002dexpressions" accesskey="n" rel="next">Enforce-expressions</a>, Previous: <a href="#Eval-expressions" accesskey="p" rel="prev">Eval expressions</a>, Up: <a href="#Logical-Expressions" accesskey="u" rel="up">Logical Expressions</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Call_002dexpressions-1"></span><h4 class="subsection">4.5.8 Call-expressions</h4>
<p>A <strong>call-expression</strong> has the same form as a
<a href="#g_t_0023call_002dterms">call-term</a>, q.v. As with call-expressions,
eval-expressions are interpreted as either true or false.
</p>
<hr>
<span id="Enforce_002dexpressions"></span><div class="header">
<p>
Next: <a href="#Setof_002dexpressions" accesskey="n" rel="next">Setof-expressions</a>, Previous: <a href="#Call_002dexpressions" accesskey="p" rel="prev">Call-expressions</a>, Up: <a href="#Logical-Expressions" accesskey="u" rel="up">Logical Expressions</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Enforce_002dexpressions-1"></span><h4 class="subsection">4.5.9 Enforce-expressions</h4>
<span id="g_t_0023enforce_002dexpressions"></span><p>An <strong>enforce-expression</strong> has the form
</p>
<div class="lisp">
<pre class="lisp">(enforce <em>t<sub>1</sub></em> &amp;rest <em>error-args</em>)
</pre></div>
<p>Enforce expressions are for goals that should <em>always</em> be
satisfied. SHOP&rsquo;s theorem-prover will attempt to prove <em>t</em> and if
it fails, will call error with <em>error-args.</em> For example
</p>
<div class="lisp">
<pre class="lisp">(enforce (x-position ?aircraft)
          &quot;~A x-position undefined.&quot; (quote ?aircraft))
</pre></div>

<hr>
<span id="Setof_002dexpressions"></span><div class="header">
<p>
Next: <a href="#Bagof_002dexpressions" accesskey="n" rel="next">Bagof-expressions</a>, Previous: <a href="#Enforce_002dexpressions" accesskey="p" rel="prev">Enforce-expressions</a>, Up: <a href="#Logical-Expressions" accesskey="u" rel="up">Logical Expressions</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Setof_002dexpressions-1"></span><h4 class="subsection">4.5.10 Setof-expressions</h4>
<span id="g_t_0023setof_002dexpressions"></span><p>A <strong>setof-expression</strong> has the form
</p>
<div class="lisp">
<pre class="lisp">(setof <em>var expr set-var</em>)
</pre></div>
<p>Find all solutions to <em>expr,</em> and bind the <em>set of</em> values for
<em>var</em> in <em>expr</em> to <em>set-var</em>. For example
</p>
<div class="lisp">
<pre class="lisp">(setof ?uav (uav ?uav) ?uavs)
</pre></div>


<p>will bind <code>?uavs</code> to the set of UAVs in the current state.
</p>
<p>Note that the semantics of this operator are to fail if the <em>expr</em>
is an unsatisfiable goal.
</p>
<hr>
<span id="Bagof_002dexpressions"></span><div class="header">
<p>
Previous: <a href="#Setof_002dexpressions" accesskey="p" rel="prev">Setof-expressions</a>, Up: <a href="#Logical-Expressions" accesskey="u" rel="up">Logical Expressions</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Bagof_002dexpressions-1"></span><h4 class="subsection">4.5.11 Bagof-expressions</h4>
<span id="g_t_0023bagof_002dexpressions"></span><p>The syntax for bagof is the same as for setof (Section 4.5.10), but
binds <em>set-var</em> to a <em>bag</em> of results, which may contain
duplicates, instead of a set.
</p>
<hr>
<span id="Logical-Precondition"></span><div class="header">
<p>
Next: <a href="#Axioms" accesskey="n" rel="next">Axioms</a>, Previous: <a href="#Logical-Expressions" accesskey="p" rel="prev">Logical Expressions</a>, Up: <a href="#The-SHOP3-Formalism" accesskey="u" rel="up">The SHOP3 Formalism</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Logical-Precondition-1"></span><h3 class="section">4.6 Logical Precondition</h3>
<span id="g_t_0023logical_002dprecondition"></span><p>A <strong>logical precondition</strong> is a either logical expression or one of
the following special precondition forms: <strong>first satisfier
precondition</strong>, <strong>sorted precondition</strong>.
</p><table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#First-Satisfiers-Precondition" accesskey="1">First Satisfiers Precondition</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Sorted-Precondition" accesskey="2">Sorted Precondition</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr>
<span id="First-Satisfiers-Precondition"></span><div class="header">
<p>
Next: <a href="#Sorted-Precondition" accesskey="n" rel="next">Sorted Precondition</a>, Previous: <a href="#Logical-Precondition" accesskey="p" rel="prev">Logical Precondition</a>, Up: <a href="#Logical-Precondition" accesskey="u" rel="up">Logical Precondition</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="First-Satisfiers-Precondition-1"></span><h4 class="subsection">4.6.1 First Satisfiers Precondition</h4>
<span id="g_t_0023first_002dsatisfiers_002dprecondition"></span><p>A <strong>first satisfier precondition</strong> has the form
</p>
<div class="lisp">
<pre class="lisp">(:first <em>l<sub>1</sub> l<sub>2</sub> ... l<sub>n</sub></em>)
</pre></div>
<p>where each <em>l<sub>i </sub></em> is a logical expression. Such a precondition
causes <small>SHOP3</small> to consider only the first set of bindings that satisfies
all of the given expressions. Alternative bindings will not be
considered even if the first bindings found do not lead to a valid plan.
</p>
<hr>
<span id="Sorted-Precondition"></span><div class="header">
<p>
Previous: <a href="#First-Satisfiers-Precondition" accesskey="p" rel="prev">First Satisfiers Precondition</a>, Up: <a href="#Logical-Precondition" accesskey="u" rel="up">Logical Precondition</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Sorted-Precondition-1"></span><h4 class="subsection">4.6.2 Sorted Precondition</h4>
<span id="g_t_0023sorted_002dprecondition"></span><p>A <strong>sorted precondition</strong> has the form
</p>
<div class="lisp">
<pre class="lisp">(:sort-by <em>?v [e] l</em>)
</pre></div>
<p>where <em>?v</em> is a variable symbol, <em>e</em> is a general Lisp
expression (which should evaluate to a comparison function), and
<em>l</em> is a logical expression. Such a precondition causes <small>SHOP3</small> to
consider bindings for the precondition in a specific order.
Specifically, bindings are sorted such that if the specified comparison
function holds between values <em>x</em> and <em>y</em> then bindings that
bind <em>?v</em> to <em>x</em> may not occur after bindings that bind
<em>?v</em> to <em>y</em>. For example consider the precondition:
</p>
<div class="lisp">
<pre class="lisp">(:sort-by ?d #'&gt; (and (at ?here) (distance ?here ?there ?d)))
</pre></div>


<p>This precondition will cause <small>SHOP3</small> to consider bindings in decreasing
(high to low) order of the value of <em>?d</em>. If the comparison
function (<em>e</em>) is omitted, it defaults to #&rsquo;&lt;, indicating
increasing (low to high) order.
</p>
<hr>
<span id="Axioms"></span><div class="header">
<p>
Next: <a href="#Task-Atoms" accesskey="n" rel="next">Task Atoms</a>, Previous: <a href="#Logical-Precondition" accesskey="p" rel="prev">Logical Precondition</a>, Up: <a href="#The-SHOP3-Formalism" accesskey="u" rel="up">The SHOP3 Formalism</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Axioms-1"></span><h3 class="section">4.7 Axioms</h3>
<span id="g_t_0023axioms"></span><p>An <strong>axiom</strong> is an expression of the form
</p>
<div class="lisp">
<pre class="lisp">(:- a
    [name<sub>1</sub>] <em>E<sub>1</sub></em>
    [name<sub>2</sub>] E<sub>2</sub>
    [name<sub>3</sub>] E<sub>3</sub> ...
    [name<sub>n</sub>] E<sub>n</sub>)
</pre></div>
<p>where the axiom&rsquo;s <strong>head</strong> is the symbol <em>a</em>, and its
<strong>tail</strong> is the list ([<em>name<sub>1</sub></em>] <em>E<sub>1</sub></em>
[<em>name<sub>2</sub></em>] <em>E<sub>2</sub></em> [<em>name<sub>3</sub></em>]
<em>E<sub>3</sub></em> ... [<em>name<sub>n</sub></em>] <em>E<sub>n</sub></em>) and each
<em>E</em><sub>i</sub> is a logical expression and each <em>name<sub>i</sub></em> is a
symbol called the <em>name</em> of <em>E<sub>i</sub></em>. The names of the
expressions are optional. When a domain definition is loaded into <small>SHOP3</small>,
a unique name will be generated for each conjunct if no name was given.
These names have no semantic meaning to <small>SHOP3</small>, but are provided to help
the user debug domain descriptions by looking at traces of <small>SHOP3</small>&rsquo;s
behavior.
</p>
<p>The intended meaning of an axiom is that <em>a</em> is true if
<em>E<sub>1</sub></em> is true, or if <em>E<sub>1</sub></em> is false but
<em>E<sub>2</sub></em> is true, or if all of <em>E<sub>1</sub></em>, <em>E<sub>2</sub></em>,
... , <em>E<sub>n-1</sub></em> are false but <em>E<sub>n</sub></em> is true. For
example, the following axiom says that a location is in walking distance
if the weather is good and the location is within two miles of home, or
if the weather is not good and the location is within one mile of home:
</p>
<div class="lisp">
<pre class="lisp">(:- (walking-distance ?x)
     good ((weather-is good) (distance home ?x ?d) (call &lt;= ?d 2))
     bad ((distance home ?x ?d) (call &lt;= ?d 1)))
</pre></div>


<hr>
<span id="Task-Atoms"></span><div class="header">
<p>
Next: <a href="#Task-Lists" accesskey="n" rel="next">Task Lists</a>, Previous: <a href="#Axioms" accesskey="p" rel="prev">Axioms</a>, Up: <a href="#The-SHOP3-Formalism" accesskey="u" rel="up">The SHOP3 Formalism</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Task-Atoms-1"></span><h3 class="section">4.8 Task Atoms</h3>
<span id="g_t_0023task_002datoms"></span><p>A <strong>task atom</strong> is an expression of any of the forms
</p>
<div class="lisp">
<pre class="lisp">(<em>s</em> <em>t<sub>1</sub></em> <em>t<sub>2</sub></em> ... <em>t<sub>n</sub></em>)

(:task <em>s</em> <em>t<sub>1</sub></em> <em>t<sub>2</sub></em> ... <em>t<sub>n</sub></em>)

(:task :immediate <em>s</em> <em>t<sub>1</sub></em> <em>t<sub>2</sub></em> ... <em>t<sub>n</sub></em>)
</pre></div>
<p>where <em>s</em> is a task symbol and the arguments <em>t<sub>1</sub>,
t<sub>2</sub>, ..., t<sub>n</sub></em> are terms. The task atom is <strong>primitive</strong>
if <em>s</em> is a primitive task symbol, and it is <strong>compound</strong> if
<em>s</em> is a compound task symbol. The first and second forms are
called an <strong>ordinary task atom</strong>; the third form is called an
<strong>immediate task atom</strong>. The purpose of the <code>:immediate</code> keyword is
to give a higher priority to the task, as described in the following
subsection.
</p>
<hr>
<span id="Task-Lists"></span><div class="header">
<p>
Next: <a href="#Operators" accesskey="n" rel="next">Operators</a>, Previous: <a href="#Task-Atoms" accesskey="p" rel="prev">Task Atoms</a>, Up: <a href="#The-SHOP3-Formalism" accesskey="u" rel="up">The SHOP3 Formalism</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Task-Lists-1"></span><h3 class="section">4.9 Task Lists</h3>
<span id="g_t_0023task_002dlists"></span><p>A <strong>task list</strong> is any of the following:
</p>
<ul>
<li> an expression of the form (:unordered <em>tasklist<sub>1</sub>
tasklist<sub>2</sub> ... tasklist<sub>n</sub></em>), where <em>tasklist<sub>1</sub>
tasklist<sub>2</sub> ... tasklist<sub>n</sub></em> are task lists;

</li><li> an expression of the form ([:ordered] <em>tasklist<sub>1</sub>
tasklist<sub>2</sub> ... tasklist<sub>n</sub></em>), where <em>tasklist<sub>1</sub>
tasklist<sub>2</sub> ... tasklist<sub>n</sub></em> are task lists.

</li><li> A task atom, see 4.8.

</li></ul>

<p>The :ordered keyword, which is optional, specifies that <small>SHOP3</small> must
perform the task lists in the order that they are given.&nbsp;The :unordered
keyword specifies that there is no particular ordering specified between
<em>tasklist<sub>1</sub>, tasklist<sub>2</sub> ... tasklist<sub>n</sub>.&nbsp;</em> With the
use of the :unordered keyword, <small>SHOP3</small> may interleave tasks between
different task lists.&nbsp; Suppose we have two task lists as the following:
</p>
<p><em>T</em> = <code>(:ordered <em>t</em><sub>1</sub> <em>t</em><sub>2</sub> ...
<em>t<sub>m</sub></em>)</code>;
</p>
<p><em>U</em> = <code>(:ordered <em>u</em><sub>1</sub> <em>u</em><sub>2</sub> ...
<em>u<sub>n</sub></em>)</code>;
</p>
<p>and that we have the main task list
</p>
<p><em>M</em> = <code>(:unordered <em>T U</em> ).</code>
</p>
<p>If none of the tasks have the <code>:immediate</code> keyword, then the tasks in
<em>T</em> should be performed in the order given, and the tasks in
<em>U</em> should also be performed in the order given&mdash;but it is
permissible for <small>SHOP3</small> to interleave the tasks of <em>T</em> and the tasks
of <em>U</em>. However, if some of the tasks are immediate, then each time
<small>SHOP3</small> chooses the next task to accomplish, it needs to give a higher
priority to the immediate tasks. For example, if <em>t</em><sub>1</sub> is
immediate and <em>u</em><sub>1</sub> is not immediate, then <small>SHOP3</small> should
perform <em>t</em><sub>1</sub> before both <em>t</em><sub>2</sub> and <em>u</em><sub>1</sub>.
</p>
<p>Note: A task with the <code>:immediate</code> keyword specifies that this task must
be performed immediately when it has no predecessors.&nbsp; Therefore, we
can allow only one task with the <code>:immediate</code> keyword in the list of tasks
that have no predecessors.&nbsp; Otherwise, <small>SHOP3</small>&rsquo;s behavior on those tasks
is undefined.&nbsp; In other words, it is not allowed to have two tasks in
an :unordered list and both have the <code>:immediate</code> keyword.&nbsp;&nbsp; For
instance, on the example above, <em>t<sub>1</sub></em> and <em>u<sub>1</sub></em>
cannot both have the <code>:immediate</code> keyword.
</p>
<hr>
<span id="Operators"></span><div class="header">
<p>
Next: <a href="#Methods" accesskey="n" rel="next">Methods</a>, Previous: <a href="#Task-Lists" accesskey="p" rel="prev">Task Lists</a>, Up: <a href="#The-SHOP3-Formalism" accesskey="u" rel="up">The SHOP3 Formalism</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Operators-1"></span><h3 class="section">4.10 Operators</h3>
<span id="g_t_0023operators"></span>




<p>The arguments marked with keywords are all optional, and may appear in
any order. The add-list, and delete-list default to being empty. The
preconditions default to being vacuously true, and the cost defaults to
1.0.
</p>
<p><em>Note:</em> We still support <small>SHOP2</small>&rsquo;s original syntax for operators,
described below (see <a href="#Operators-Legacy-Syntax">Operators Legacy Syntax</a>).
</p>
<p>An <strong>operator</strong> is description of how to perform a <em>primitive</em>
task, which cannot be decomposed further. An operator definition has the
following form:
</p>

<div class="lisp">
<pre class="lisp">(:op <em>head</em>
       [:add <em>add-list</em>]
       [:delete <em>delete-list</em>]
       [:precond <em>precondition</em>]
       [:cost <em>cost-fn</em>])
</pre></div>

<p>where
</p>
<ul>
<li> <em>head</em> (the operator&rsquo;s <strong>head</strong>) is a primitive task atom (i.e.,
a task atom with a task symbol that begins with an exclamation point)

</li><li> The operator&rsquo;s
<em>precondition</em> is a logical expression.

</li><li> The operator&rsquo;s
<em>delete-list</em>) is a list for which each
of the element may be any of following:

<ul>
<li> a logical atom

</li><li> a protection condition (see below)

</li><li> an expression of the form (forall V E L), where <em>V</em> is a list of
variables in <em>E</em>, <em>E</em> is a logical expression, and <em>L</em> is
a list of logical atoms

</li></ul>

</li><li> The operator&rsquo;s
<em>add-list</em>) is a list of logical atoms
that has the same form as the delete-list.

</li><li> <em>cost-fn</em> (the operator&rsquo;s <strong>cost</strong>) is a general Lisp expression. If
<em>c</em> is omitted, the cost defaults to 1.

</li></ul>


<p>In the above definition, a <strong>protection condition</strong> is an
expression of the form
</p>
<div class="lisp">
<pre class="lisp">(:protection a)
</pre></div>


<p>where <em>a</em> is a logical atom. The purpose of a protection condition
in the add list is to tell <small>SHOP3</small> that it should not execute any operator
that deletes <em>a</em>. The purpose of a protection condition in the
delete list is to cancel a previously added protection condition. For
example, if we drive a delivery truck to a certain location in order to
pick up a package, then we might not want to allow the truck to be moved
away from that location until after we have picked up the package.&nbsp; To
represent this, we might use the following operators:
</p>
<div class="lisp">
<pre class="lisp">(:op (!drive-to ?truck ?old-loc ?location)
   :delete ((at ?truck ?old-loc))
   :add ((at ?truck ?location)
           (:protection (at ?truck ?location))))
(:op (!pick-up ?truck ?package ?location)
  :delete
    ((at ?package ?location)
     (:protection (at ?truck ?location)))
   :add ((in ?package ?truck)))
</pre></div>

<span id="index-internal-operators"></span>
<span id="g_t_0023internal_002doperators"></span><p>As noted above, the head of the operator is a primitive task atom, so it
must begin with a primitive task symbol, i.e., a symbol that begins with
an exclamation point. Note that operator names which begin with
<em>two</em> exclamation points have a special meaning in <small>SHOP3</small>; operators
of this sort are known as <strong>internal operators</strong>. Internal
operators are ones which are used for purposes internal to the planning
process and are not intended to correspond to actions performed in the
plan (e.g., to do some computation which will later be useful in
deciding what actions to perform). Other than requiring two exclamation
points at the start of the name, the syntax for internal operators is
identical to the syntax for other operators. <small>SHOP3</small> handles internal
operators exactly the same way as ordinary operators during planning.
<small>SHOP3</small> includes these operators in any plans that it returns at the end
of execution. It may, however, omit them from the printout of the final
plan (depending on the value of the <code>:verbose</code> argument
(see <a href="#g_t_0023verbose">verbose</a>). 
</p>
<p>The primary reason that the internal operator syntax
exists in <small>SHOP3</small> is so that automated systems which use <small>SHOP3</small> plans as an
input can easily distinguish between those operators which involve
action and those which were merely internal to the planning process.
</p>
<p>When designing an operator, it is important to ensure that each variable
symbol in the add list, delete list, and cost always be bound to a
single value when the operator is invoked. Variable symbols can be bound
in the head of the operator (by the method that invokes the associated
primitive task) or in the precondition of the operator. An operator
should be written such that for any variable appearing after the
precondition, no two unifiers of the precondition have different
bindings for that variable. <small>SHOP3</small> does not check this requirement; if
conflicting unifiers are available when applying an operator, it will
apply one arbitrarily. This can lead to unpredictable behavior and plans
with ambiguous semantics. In general, we recommend that operator
preconditions be designed such that only one unifier is possible.
However, <small>SHOP3</small> will be able to correctly process operators that have
multiple unifiers for preconditions as long as no two unifiers can
provide different values for a variable that appears in the add list,
delete list, or cost.
</p><table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#Operators-Legacy-Syntax" accesskey="1">Operators Legacy Syntax</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr>
<span id="Operators-Legacy-Syntax"></span><div class="header">
<p>
Previous: <a href="#Operators" accesskey="p" rel="prev">Operators</a>, Up: <a href="#Operators" accesskey="u" rel="up">Operators</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Operators_003a-Legacy-Syntax"></span><h4 class="subsection">4.10.1 Operators: Legacy Syntax</h4>

<p>In our work with <small>SHOP2</small>, we found that operator definitions in its
original syntax were prone to
hard-to-detect syntax errors and typos that can give rise to difficult to identify
âgarbage in/garbage outâ bugs. Particularly prevalent are
hard-to-identify bugs arising when a programmer inadvertently reverses
the order of add and delete lists in a <small>SHOP3</small> operator. These problems
are exacerbated by the extreme permissiveness of <small>SHOP3</small>&rsquo;s parser.
This led us to the new syntax, described above, which relies on keywords
to make operator definitions more readable, and less error-prone.  Our
new syntax also
supports arbitrary order and the omission of empty components, without
the &ldquo;DWIM&rdquo; parsing in <small>SHOP2</small>.
Because of its many advantages, so we encourage you to adopt the new
syntax, 
instead of continuing to use the âclassicalâ form described here,
although it is still supported.
</p>
<p>The original operator definition syntax was as follows:
</p>
<div class="lisp">
<pre class="lisp">(:operator <em>head precondition delete-list add-list</em> <em>[c]</em>)
</pre></div>

<p>The two operators described above are written in the old syntax as
follows:
</p>
<div class="lisp">
<pre class="lisp">(:operator (!drive-to ?truck ?old-loc ?location)
   ()
   ((at ?truck ?old-loc))
   ((at ?truck ?location)
    (:protection (at ?truck ?location))))
(:operator (!pick-up ?truck ?package ?location)
  ()
  ((at ?package ?location)
   (:protection (at ?truck ?location)))
  ((in ?package ?truck)))
</pre></div>

<p>For backwards compatibility with SHOP 1.x, <small>SHOP3</small> will also accept
operators where the precondition <em>P</em> is missing. In this case the
domain definition pre-processing code puts a null precondition into the
operator, which is always satisfied. <em><small>SHOP3</small>&rsquo;s ability to recognize
operators without preconditions is deprecated and is likely to disappear
in the future.</em>
</p>


<hr>
<span id="Methods"></span><div class="header">
<p>
Next: <a href="#Planning-Domain" accesskey="n" rel="next">Planning Domain</a>, Previous: <a href="#Operators" accesskey="p" rel="prev">Operators</a>, Up: <a href="#The-SHOP3-Formalism" accesskey="u" rel="up">The SHOP3 Formalism</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Methods-1"></span><h3 class="section">4.11 Methods</h3>
<span id="g_t_0023methods"></span><p>A <strong>method</strong> is a list of the form
</p>
<p>(:method <em>h</em> [<em>n<sub>1</sub></em>] <em>C<sub>1</sub></em> <em>T<sub>1</sub></em>
[<em>n<sub>2</sub></em>] <em>C<sub>2</sub></em> <em>T<sub>2</sub></em> ... [<em>n<sub>k</sub></em>]
<em>C<sub>k</sub></em> <em>T<sub>k</sub></em>)
</p>
<p>where
</p>
<ul>
<li> <em>h</em> (which is called the method&rsquo;s <strong>head</strong>) is a task atom in
which no <em>call- or eval-terms</em> can appear;

</li><li> Each <em>C<sub>i</sub></em> (which is called a <strong>precondition</strong> for the
method) is a logical precondition.

</li><li> Each <em>T<sub>i</sub></em> (which is called a <strong>tail</strong> of the method) is
a task list. The task atoms in the list can contain call-terms.

</li><li> Each n<em><sub>i</sub></em> is the <em>name</em> for the succeeding
<em>C<sub>i</sub> T<sub>i </sub></em>pair. These name are optional and if omitted a
unique name will be assigned for each pair. These names have no semantic
meaning to <small>SHOP3</small>, but are provided in order to help the user debug
domain descriptions by looking at traces of <small>SHOP3</small>&rsquo;s behavior.

</li></ul>

<p>A method indicates that the task specified in the method&rsquo;s head can be
performed by performing all of the tasks in one of the methods tails
when one that tail&rsquo;s precondition is satisfied. Note that the
preconditions are considered in the given order, and a later
precondition is considered <em>only</em> if all of the earlier
preconditions are not satisfied. If there are multiple methods for a
given task available at some point in time, all of these methods can be
considered. Consequently, the following code:
</p>
<div class="lisp">
<pre class="lisp">(:method (eat ?food)

(have-fork ?fork)

((!eat-with-fork ?food ?fork))

(have-spoon ?spoon)

((!eat-with-spoon ?food ?spoon))
</pre></div>
<p>is semantically equivalent to the following code with multiple methods
and explicitly exclusive preconditions:
</p>
<div class="lisp">
<pre class="lisp">(:method (eat ?food)
   (have-fork ?fork)
   ((!eat-with-fork ?food ?fork)))

(:method (eat ?food)
    (and (not (have-fork ?fork)) (have-spoon ?spoon))
    ((!eat-with-spoon ?food ?spoon))
</pre></div>
<p>In both of the above examples, the !eat-with-spoon operator may be
performed only if the (have-spoon ?spoon) is satisfied <em>and</em>
(have-fork ?fork) is not satisfied.
</p>
<hr>
<span id="Planning-Domain"></span><div class="header">
<p>
Next: <a href="#Planning-Problem" accesskey="n" rel="next">Planning Problem</a>, Previous: <a href="#Methods" accesskey="p" rel="prev">Methods</a>, Up: <a href="#The-SHOP3-Formalism" accesskey="u" rel="up">The SHOP3 Formalism</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Planning-Domain-1"></span><h3 class="section">4.12 Planning Domain</h3>
<span id="g_t_0023planning_002ddomain"></span><p>A <strong>planning domain</strong> is an object that contains all of the
information for solving a class of planning problems<a id="DOCF2" href="#FOOT2"><sup>2</sup></a>. At a minimum, it will include
definitions of the operators (or actions) and methods available in the
domain. A planning domain definition may also contain axioms, or other
items that are accepted by specific SHOP domain extensions. Finally, a
domain definition can <em>include</em> other domains by reference (see ,
below).
</p><table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#Simple-Form" accesskey="1">Simple Form</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Extended-form" accesskey="2">Extended form</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Inclusion-directives" accesskey="3">Inclusion directives</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr>
<span id="Simple-Form"></span><div class="header">
<p>
Next: <a href="#Extended-form" accesskey="n" rel="next">Extended form</a>, Previous: <a href="#Planning-Domain" accesskey="p" rel="prev">Planning Domain</a>, Up: <a href="#Planning-Domain" accesskey="u" rel="up">Planning Domain</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Simple-Form-1"></span><h4 class="subsection">4.12.1 Simple Form</h4>
<span id="g_t_0023simple_002dform"></span><p>A planning domain definition in the simple form looks like this:
</p>
<div class="lisp">
<pre class="lisp">(defdomain <em>domain-name</em> (<em>i<sub>1</sub></em> <em>i<sub>2</sub></em> ... <em>i<sub>n</sub></em>))
</pre></div>

<p>where <em>domain-name</em> is a symbol (which does not need to be quoted).
Beginning users of SHOP should simply use the simple domain-name form of
this argument.
</p>
<p>Each item <em>i<sub>i</sub></em> is one of the following: an operator, a
method, or an axiom. Note that domain names are not used in <small>SHOP3</small>; they
are left in the syntax for backward compatibility.
</p>
<hr>
<span id="Extended-form"></span><div class="header">
<p>
Next: <a href="#Inclusion-directives" accesskey="n" rel="next">Inclusion directives</a>, Previous: <a href="#Simple-Form" accesskey="p" rel="prev">Simple Form</a>, Up: <a href="#Planning-Domain" accesskey="u" rel="up">Planning Domain</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Extended-form-1"></span><h4 class="subsection">4.12.2 Extended form</h4>
<span id="g_t_0023extended_002dform"></span><p>The extended form of the <small>SHOP3</small> domain definition looks like this:
</p>
<div class="lisp">
<pre class="lisp">(defdomain (<em>domain-name</em> &amp;rest <em>args</em>) (<em>i<sub>1</sub></em>
<em>i<sub>2</sub></em> ... <em>i<sub>n</sub></em>))
</pre></div>

<p><em>args</em> includes the following keyword arguments:
</p>
<ul>
<li> a :type keyword argument, allowing the domain modeler to indicate a
specific subclass of the <small>SHOP3</small> domain class. E.g., one might have
(my-domain :type pddl-domain).

</li><li> A :redefine-ok argument. If this is NIL (the default), defdomain will
warn when the domain <em>domain-name</em> is already defined.

</li><li> A :noset argument. Currently this defaults to NIL, to provide for
backward compatibility, but I would like to see this move to defaulting
to T.

</li></ul>

<span id="index-_002adomain_002a"></span>

<p>This is actually a bit of a kludge. The existing defdomain form, as a
side-effect, sets the global variable <var>*domain*</var>. If this were only a
default domain name, that would be fine, but it is used everywhere as a
special variable to mean âthe domain within which we are planning.â So
if there&rsquo;s concurrent action, or there are multiple copies of SHOP (or
its component libraries) running in a single Lisp image, bad things can
happen. I would like to stamp out the use of <var>*domain*</var> as a default
domain.
</p>
<p>The question of which additional arguments are accepted in <em>args</em>
is a matter for the implementer of the specialized domain type being
used. Any additional arguments will be passed to the make-instance
method for the domain class.<a id="DOCF3" href="#FOOT3"><sup>3</sup></a> <small>SHOP3</small> extenders can create new subclasses of
domain that accept initialization arguments. A first example of the use
of this is the built-in pddl-domain class.
</p>
<p>If you are using the extended form of defdomain, you should have in hand
a new <small>SHOP3</small> domain subclass, with a description of its arguments. If you
do not, you should ignore the extended form.
</p>
<hr>
<span id="Inclusion-directives"></span><div class="header">
<p>
Previous: <a href="#Extended-form" accesskey="p" rel="prev">Extended form</a>, Up: <a href="#Planning-Domain" accesskey="u" rel="up">Planning Domain</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Inclusion-directives-1"></span><h4 class="subsection">4.12.3 Inclusion directives</h4>
<span id="index-_003ainclude"></span>
<span id="index-include-directives"></span>
<span id="index-domain-inclusion"></span>

<p>A domain definition can include the items of another domain by reference
using the include directive:
</p>
<div class="lisp">
<pre class="lisp">(:include <em>domain-name file-name</em>)
</pre></div>


<p>for example
</p>
<div class="lisp">
<pre class="lisp">(:include flight-operators
  #.(asdf:system-relative-pathname &quot;core-domains&quot; &quot;domains.lisp&quot;))
</pre></div>


<p>would take the text of the flight-operators domain, which should be
found in the domains.lisp file. Note the use of the reader evaluation
form &ndash; <code>#.</code> &ndash; to force evaluation of the expression that yields the
pathname.
</p>
<hr>
<span id="Planning-Problem"></span><div class="header">
<p>
Next: <a href="#Planning-Problem-Set" accesskey="n" rel="next">Planning Problem Set</a>, Previous: <a href="#Planning-Domain" accesskey="p" rel="prev">Planning Domain</a>, Up: <a href="#The-SHOP3-Formalism" accesskey="u" rel="up">The SHOP3 Formalism</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Planning-Problem-1"></span><h3 class="section">4.13 Planning Problem</h3>

<span id="index-defproblem"></span>
<span id="index-planning-problem"></span>
<span id="index-_002aproblem_002a"></span>

<p>A <strong>planning problem</strong> has the form
</p>
<p>(defproblem <em>problem-name domain-name</em> (<em>a<sub>1</sub></em>
<em>a<sub>2</sub></em> ... <em>a<sub>n</sub></em>) <em>T</em>)
</p>
<p>where <em>problem-name</em> is a symbol, <em>domain-name</em> is a symbol,
each a<em><sub>i</sub></em> is a ground logical atom, and <em>T</em> is a task
list. This form defines a problem which may be solved by addressing the
tasks in <em>T,</em> using the operators, methods and axioms in
<em>domain-name,</em> starting in an initial state defined by the atoms
a<em><sub>1</sub></em> through a<em><sub>n</sub></em>.
</p>
<span id="index-defproblem-1"></span>
<span id="Macro-defproblem"></span><dl>
<dt id="index-defproblem-2">Macro: <strong>defproblem</strong> <em>problem-name &amp;rest args</em></dt>
<dd><p>(<code>defproblem</code> {&lt;name&gt;|&lt;name-and-options&gt;} &lt;state&gt; &lt;tasks&gt;)
For backward compatibility, will support also
   <code>(defproblem &lt;name&gt; &lt;domain-name&gt; &lt;state&gt; &lt;tasks&gt;)</code>.
</p></dd></dl>

<p>The corresponding functional interface is:
</p>
<span id="index-make_002dproblem"></span>
<span id="Function-make_002dproblem"></span><dl>
<dt id="index-make_002dproblem-1">Function: <strong>make-problem</strong> <em>problem-name-etc state tasks &amp;rest extras</em></dt>
<dd><p><code>make-problem</code> creates a planning problem named <code>problem-name</code>
by putting <code>state</code> and <code>task</code> onto PROBLEM-NAME&rsquo;s property list under the
indicators <code>:state</code> and <code>:tasks</code>.  As a side effect, sets the global
variable <code>*problem*</code>.
</p></dd></dl>

<hr>
<span id="Planning-Problem-Set"></span><div class="header">
<p>
Next: <a href="#Plans" accesskey="n" rel="next">Plans</a>, Previous: <a href="#Planning-Problem" accesskey="p" rel="prev">Planning Problem</a>, Up: <a href="#The-SHOP3-Formalism" accesskey="u" rel="up">The SHOP3 Formalism</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Planning-Problem-Set-1"></span><h3 class="section">4.14 Planning Problem Set</h3>
<span id="index-def_002dproblem_002dset"></span>

<p>A <strong>planning problem set</strong> has the form
</p>
<div class="lisp">
<pre class="lisp">(def-problem-set <em>set-name</em> (<em>p<sub>1</sub></em> <em>p<sub>2</sub></em> ... <em>p<sub>n</sub></em>))
</pre></div>

<p>where <em>set-name</em> is a symbol and each p<em><sub>i</sub></em> is the name
of a planning problem.
</p>
<hr>
<span id="Plans"></span><div class="header">
<p>
Previous: <a href="#Planning-Problem-Set" accesskey="p" rel="prev">Planning Problem Set</a>, Up: <a href="#The-SHOP3-Formalism" accesskey="u" rel="up">The SHOP3 Formalism</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Plans-1"></span><h3 class="section">4.15 Plans</h3>
<span id="index-plans"></span>

<p>The previous subsections describe the inputs to <small>SHOP3</small>. This subsection
describes the result that <small>SHOP3</small> produces. A <strong>plan</strong> is a list of
the form
</p>
<p><em>(h<sub>1</sub> c<sub>1</sub> h<sub>2</sub> c<sub>2</sub> ... h<sub>n</sub> c<sub>n</sub> )</em>
</p>
<p>where each <em>h<sub>i</sub></em> and <em>c<sub>i</sub></em>, respectively, are the
head and the cost of a ground operator instance <em>o<sub>i</sub></em>. If
<em>p</em> = (<em>h<sub>1</sub></em> <em>c<sub>1</sub> h<sub>2</sub></em> <em>c<sub>2</sub></em> ...
<em>h<sub>n</sub> c<sub>n</sub></em>) is a plan and <em>S</em> is a state, then
<em>p</em>(<em>S</em>) is the state produced by starting with <em>S</em> and
executing <em>o<sub>1</sub></em>, <em>o<sub>2</sub></em>, ..., <em>o<sub>n</sub></em> in the
order given. The <strong>cost</strong> of the plan <em>p</em> is <em>c<sub>1 </sub></em>+
<em>c<sub>2 </sub></em>+ ... + <em>c<sub>n</sub></em> (thus, the cost of the empty
plan is 0).
</p>
<p>Often what is wanted is a truncated version of the plan sequence, with
the <em>internal operators</em> 
(see <a href="#g_t_0023internal_002doperators">internal operators</a>) 
and costs removed.  For this, one may use
</p>
<span id="index-shorter_002dplan"></span>
<span id="Function-shorter_002dplan"></span><dl>
<dt id="index-shorter_002dplan-1">Function: <strong>shorter-plan</strong> <em>plan</em></dt>
<dd><p>Removes the internal operators and costs from a plan sequence, and
returns the resulting new sequence.  Non-destructive.
</p></dd></dl>


<hr>
<span id="PDDL-Support"></span><div class="header">
<p>
Next: <a href="#The-SHOP-Theorem-Prover" accesskey="n" rel="next">The SHOP Theorem Prover</a>, Previous: <a href="#The-SHOP3-Formalism" accesskey="p" rel="prev">The SHOP3 Formalism</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="PDDL-Support-1"></span><h2 class="chapter">5 PDDL Support</h2>
<span id="g_t_0023pddl_002dcompatibility"></span><p>The current release of <small>SHOP3</small> provides a preliminary capability to
incorporate PDDL domain definitions into a <small>SHOP3</small> domain. You should be
able to incorporate components of a PDDL domain definition into a <small>SHOP3</small>
domain definition of :type pddl-domain or simple-pddl-domain. A
pddl-domain corresponds to a PDDL domain of the ADL type. The
pddl-domain uses conditional-effects, existential-preconditions,
universal-preconditions, and equality (note that these are <em>PDDL</em>
conditional effects, existential preconditions and universal
preconditions; these are <em>not</em> SHOP-syntax condition effects,
etc.). A simple-pddl-domain will not have conditional-effects,
existential-preconditions, universal-preconditions, or equality.
</p>
<p>Currently the PDDL integration is a little bumpy, and details are in
flux.
</p>
<p>PDDL action names are translated into names that SHOP will recognize as
primitives (e.g., move would become !move, and would have to be
referenced that way in SHOP method definitions that use it).
</p>
<p>You must splice the PDDL domain components into the SHOP domain
definition. Typically, the best way to do this is to use an :include
form (see ).
</p>
<p>Fully ground STRIPS-style domains &ndash; i.e., those where a set of STRIPS
operators has been exploded into a large set of ground operators by some
automated transformation &ndash; will work very poorly.
</p>
<p>Note that the parsing of PDDL domains in SHOP is not strict. This is
intentional, because we don&rsquo;t want to make it impossible to include SHOP
constructs together with PDDL constructs. However, there should probably
be a âstrict modeâ that checks for true conformance with PDDL syntax.
</p><table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#PDDL-Methods" accesskey="1">PDDL Methods</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr>
<span id="PDDL-Methods"></span><div class="header">
<p>
Previous: <a href="#PDDL-Support" accesskey="p" rel="prev">PDDL Support</a>, Up: <a href="#PDDL-Support" accesskey="u" rel="up">PDDL Support</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="PDDL-Methods-1"></span><h3 class="section">5.1 PDDL Methods</h3>
<span id="g_t_0023pddl_002dmethods"></span><p>In order to support replanning, we have developed âPDDL methodsâ that
have more limited expressive power than normal <small>SHOP3</small> methods, and that
have clearer semantics. This feature is <em>experimental:</em> the syntax,
semantics, and implementation are all likely to change.
</p>
<p>PDDL method proposed syntax:
</p>
<div class="lisp">
<pre class="lisp">(:pddl-method <em>head<sub>[Ï]</sub> precond<sub>[Ï]</sub> body<sub>[Ï]</sub></em>)
</pre></div>


<p>As in normal <small>SHOP3</small> methods (see Section 4.11), a PDDL Method&rsquo;s head is a
task. We notate it here as <em>head<sub>[Ï]</sub></em> in order to indicate
that some set of variables, Ï, may appear free in the head. Similarly,
we have <em>precond<sub>[Ï]</sub></em> and <em>body<sub>[Ï] </sub></em>to indicate
that Ï may appear free in the preconditions and the body. A PDDL
method&rsquo;s preconditions must be an enhanced PDDL goal expression (see
below). A PDDL method&rsquo;s body must be an ordered task network. In the
interests of clean syntax, task network keywords (:ordered and
:unordered) are <em>not</em> optional, and must be provided. For the
moment, only ordered task networks are supported; unordered task
networks may be supported later.
</p>
<p>Note that provision for free variables does not relax the constraint
that all operators must be ground when inserted into the plan. The
intention is to allow the variables in Ï to be bound by the
preconditions. As in PDDL operators, only the variables in the head of a
PDDL method are scoped over the preconditions and the body (in standard
<small>SHOP3</small> methods we have Prolog-style scoping where any free variable is
implicitly scoped over the entire method).
</p>
<p>Note also that PDDL methods do <em>not</em> permit multiple precondition
sets and task networks in a single PDDL method form, and so do
<em>not</em> support the if-then-else semantics of <small>SHOP3</small> method forms. To
get this kind of semantics in PDDL methods, the programmer must supply a
set of methods with mutually-exclusive and exhaustive preconditions.
</p>
<p>PDDL methods may only be used in domains that are a subclass of
<code>SIMPLE-PDDL-DOMAIN</code> (see Section 8.1.2).
</p><table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#Enhanced-Preconditions" accesskey="1">Enhanced Preconditions</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#PDDL-Domain-Classes" accesskey="2">PDDL Domain Classes</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr>
<span id="Enhanced-Preconditions"></span><div class="header">
<p>
Next: <a href="#PDDL-Domain-Classes" accesskey="n" rel="next">PDDL Domain Classes</a>, Previous: <a href="#PDDL-Methods" accesskey="p" rel="prev">PDDL Methods</a>, Up: <a href="#PDDL-Methods" accesskey="u" rel="up">PDDL Methods</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Enhanced-Preconditions-1"></span><h4 class="subsection">5.1.1 Enhanced Preconditions</h4>
<span id="g_t_0023enhanced_002dpreconditions"></span><p>PDDL method preconditions are based on PDDL <em>goals</em>, but with the
following extensions:
</p>
<ul>
<li> A PDDL method&rsquo;s preconditions may use the <code>:sort-by</code>        keyword. More
precisely:

</li></ul>

<blockquote>
<p>precond ::= &lt;PDDL goalÏ&gt;|
</p>
<p>(:sort-by &lt;var&gt; [&lt;rel&gt;] &lt;PDDL goal<sub>&lt;var&gt;,Ï</sub>&gt;
</p></blockquote>
<ul>
<li> As noted above, variables that appear free in the head of the PDDL
method may appear free in the precondition, hence the use of &lt;PDDL
goalÏ&gt; and &lt;PDDL goal<sub>&lt;var&gt;,Ï</sub>&gt;.

</li></ul>

<p>PDDL goals are as described in the PDDL syntax (we have used the PDDL
2.1 paper as primary source). Note that PDDL goals with free variables
are permitted, as long as the free variables appear in the parameters
for the task.
</p>
<p>Currently we do not support typing in PDDL method task heads, but this
could change.
</p>
<hr>
<span id="PDDL-Domain-Classes"></span><div class="header">
<p>
Previous: <a href="#Enhanced-Preconditions" accesskey="p" rel="prev">Enhanced Preconditions</a>, Up: <a href="#PDDL-Methods" accesskey="u" rel="up">PDDL Methods</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="PDDL-Domain-Classes-1"></span><h4 class="subsection">5.1.2 PDDL Domain Classes</h4>
<span id="g_t_0023pddl_002ddomain_002dclasses"></span><p>In order to implement the requirements of PDDL, <small>SHOP3</small> contains a number
of classes, which can be used when defining domains with defdomain (see
Section 4.12):
</p>
<ul>
<li> SIMPLE-PDDL-DOMAIN &ndash; this is the base class. All PDDL domain classes
should include this class.

</li><li> PDDL-DOMAIN &ndash; for historical reasons, this class corresponds roughly to
PDDL domains with the ADL requirements. Use of this class is
<em>deprecated;</em> it was added without sufficient thought.

</li><li> ADL-DOMAIN &ndash; SIMPLE-PDDL-DOMAIN with ADL-MIXIN (see below).

</li><li> Mixin classes for different requirements:

<ul>
<li> NEGATIVE-PRECONDITIONS-MIXIN

</li><li> DISJUNCTIVE-PRECONDITIONS-MIXIN

</li><li> UNIVERSAL-PRECONDITIONS-MIXIN

</li><li> EXISTENTIAL-PRECONDITIONS-MIXIN

</li><li> QUANTIFIED-PRECONDITIONS-MIXIN &ndash; this simply inherits universal and
existential preconditions, since they are typically used together.

</li><li> CONDITIONAL-EFFECTS-MIXIN

</li><li> EQUALITY-MIXIN

</li><li> PDDL-TYPING-MIXIN

</li><li> COSTS-MIXIN

</li><li> ADL-MIXIN

</li></ul>

</li></ul>

<hr>
<span id="The-SHOP-Theorem-Prover"></span><div class="header">
<p>
Next: <a href="#The-SHOP-Unifier" accesskey="n" rel="next">The SHOP Unifier</a>, Previous: <a href="#PDDL-Support" accesskey="p" rel="prev">PDDL Support</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="The-SHOP-Theorem-Prover-1"></span><h2 class="chapter">6 The SHOP Theorem Prover</h2>
<span id="g_t_0023using_002dthe_002dshop_002dtheorem_002dprover"></span><p>One of the main extensions that SIFT has made to <small>SHOP3</small> is to make its
theorem prover usable separately. The <small>SHOP3</small> theorem-prover is very
similar to Prolog, but operates over a state that changes over time.
Note, however, that the prover does not (at least not yet) support
temporal modalities such as &ldquo;previously,&rdquo; &ldquo;next,&rdquo; or &ldquo;always.&rdquo;
</p>
<p>The theorem-prover is supplied only as a toolbox unlike the unifier
(see <a href="#The-SHOP-Unifier">The SHOP Unifier</a>), which provides functionality that is ready to
use &ldquo;out-of-the box.&rdquo;  Specifically, it does not contain any built-in
functionality for advancing the world state; those need to be developed
by the programmer, based on facilities supplied by <small>SHOP3</small>&rsquo;s
&ldquo;common&rdquo; subsystem.
The theorem-prover makes relies critically on the unifier subsystem, and
re-exports from the theorem-prover package most of the key functions
from the unifier package.
</p>
<p>The top-level function of the theorem-prover is <em>query</em>, which is
built on top of the more difficult-to-use <em>find-satisfiers</em>:
</p>
<span id="index-query-_005bshopthpr_005d"></span>
<span id="Generic_002dFunction-shopthpr_003aquery"></span><dl>
<dt id="index-query-_005bshopthpr_005d-1">Generic Function: <strong>query [shopthpr]</strong> <em>goals state &amp;key just-one domain record-dependencies</em></dt>
<dd><p>More convenient top-level alternative to <code>find-satisfiers</code>.
Manages optional arguments and ensures that the variable property
is properly set in <code>goals</code>.
</p></dd></dl>
<span id="index-find_002dsatisfiers-_005bshopthpr_005d"></span>
<span id="Function-shopthpr_003afind_002dsatisfiers"></span><dl>
<dt id="index-find_002dsatisfiers-_005bshopthpr_005d-1">Function: <strong>find-satisfiers [shopthpr]</strong> <em>goals state &amp;optional just-one level &amp;key domain</em></dt>
<dd><p>Find and return a list of binding lists that represents the answer to
goals (a list representation of a deductive query), where
state provides the database.  level is a non-negative integer indicating the
current depth of inference, used in debugging prints, and
<code>just-one</code> is a boolean indicating whether you want just one answer (non-nil)
or all answers (nil).
</p></dd></dl>


<p>The theorem prover has its own notion of a <em>domain</em> object, but
unlike the full <small>SHOP3</small> domain, this one supports only specification
of axioms (although it can be extended by the programmer).
</p>
<span id="index-thpr_002ddomain-_005bshopthpr_005d"></span>
<span id="Class-shopthpr_003athpr_002ddomain"></span><dl>
<dt id="index-thpr_002ddomain-_005bshopthpr_005d-1">Class: <strong>thpr-domain [shopthpr]</strong></dt>
<dd><p>Class precedence list: <code>thpr-domain, has-axioms-mixin, standard-object, t</code>
</p>
<p>An object representing a SHOP3 theorem prover domain.
</p></dd></dl>


<hr>
<span id="The-SHOP-Unifier"></span><div class="header">
<p>
Next: <a href="#Plan-Grapher" accesskey="n" rel="next">Plan Grapher</a>, Previous: <a href="#The-SHOP-Theorem-Prover" accesskey="p" rel="prev">The SHOP Theorem Prover</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="The-SHOP-Unifier-1"></span><h2 class="chapter">7 The SHOP Unifier</h2>

<p>The <small>SHOP3</small> unifier may be loaded stand-alone with
</p><div class="example">
<pre class="example">(asdf:load-system &quot;shop3/unifier&quot;)
</pre></div>

<p>It provides a library that may be useful for general symbolic
computation that requires unification of first order (or, indeed, higher
order) logical expressions represented as lisp s-expressions.
</p>
<span id="index-unify-_005bshopunif_005d"></span>
<span id="Function-shopunif_003aunify"></span><dl>
<dt id="index-unify-_005bshopunif_005d-1">Function: <strong>unify [shopunif]</strong> <em>e1 e2</em></dt>
<dd><p>Checks to see whether or not E1 and E2 unify, returning a
substitution (a binding list)
if they do, or <code>fail</code> <code>(*not* nil) </code>if they don&rsquo;t.
</p></dd></dl>

<p>The <code>unify</code> function is also exported from the <small>SHOP3</small>
theorem-prover package and the top level <small>SHOP3</small> package.
</p>
<p>To check the results of unification, <small>SHOP3</small> offers these predicates:
</p>
<span id="index-unify_002dp-_005bshopunif_005d"></span>
<span id="Macro-shopunif_003aunify_002dp"></span><dl>
<dt id="index-unify_002dp-_005bshopunif_005d-1">Macro: <strong>unify-p [shopunif]</strong> <em>e1 e2</em></dt>
<dd><p>It&rsquo;s painful (and bug-inducing) to have to remember to compare the
result of unify with &rsquo;fail.  This checks to see whether E1 and E2
unify, and returns <code>t</code> or <code>nil</code>, accordingly.
</p></dd></dl>
<span id="index-unify_002dfail-_005bshopunif_005d"></span>
<span id="Macro-shopunif_003aunify_002dfail"></span><dl>
<dt id="index-unify_002dfail-_005bshopunif_005d-1">Macro: <strong>unify-fail [shopunif]</strong> <em>e1 e2</em></dt>
<dd><p>It&rsquo;s painful (and bug-inducing) to have to remember to compare the
result of unify with &rsquo;fail.
</p></dd></dl>
<span id="index-unify_002dfail_002dp-_005bshopunif_005d"></span>
<span id="Macro-shopunif_003aunify_002dfail_002dp"></span><dl>
<dt id="index-unify_002dfail_002dp-_005bshopunif_005d-1">Macro: <strong>unify-fail-p [shopunif]</strong> <em>e1 e2</em></dt>
<dd><p>Better-named alias for <code>unify-fail</code>.
</p></dd></dl>

<p>A <em>binding-list</em> or <em>substitution</em> is a list of
<em>bindings</em>:
</p>
<span id="index-binding-_005bshopunif_005d"></span>
<span id="Structure-shopunif_003abinding"></span><dl>
<dt id="index-binding-_005bshopunif_005d-1">Structure: <strong>binding [shopunif]</strong></dt>
<dd><p>Class precedence list: <code>binding, structure-object, t</code>
</p>
<p>A binding is a structure with a variable and a value.
</p></dd></dl>

<p>Accessors:
</p>
<span id="index-binding_002dval-_005bshopunif_005d"></span>
<span id="Function-shopunif_003abinding_002dval"></span><dl>
<dt id="index-binding_002dval-_005bshopunif_005d-1">Function: <strong>binding-val [shopunif]</strong> <em>instance</em></dt>
<dd><p>Binding structure accessor
</p></dd></dl>
<span id="index-binding_002dvar-_005bshopunif_005d"></span>
<span id="Function-shopunif_003abinding_002dvar"></span><dl>
<dt id="index-binding_002dvar-_005bshopunif_005d-1">Function: <strong>binding-var [shopunif]</strong> <em>instance</em></dt>
<dd><p>Binding structure accessor
</p></dd></dl>

<p>Utility functions:
</p>
<span id="index-make_002dbinding_002dlist-_005bshopunif_005d"></span>
<span id="Function-shopunif_003amake_002dbinding_002dlist"></span><dl>
<dt id="index-make_002dbinding_002dlist-_005bshopunif_005d-1">Function: <strong>make-binding-list [shopunif]</strong> <em>variables values</em></dt>
<dd><p>Takes a list of <code>variables</code> and <code>values</code> and returns a <code>binding-list</code>.
</p></dd></dl>
<span id="index-binding_002dlist_002dvalue-_005bshopunif_005d"></span>
<span id="Function-shopunif_003abinding_002dlist_002dvalue"></span><dl>
<dt id="index-binding_002dlist_002dvalue-_005bshopunif_005d-1">Function: <strong>binding-list-value [shopunif]</strong> <em>var binding-list &amp;optional if-not-found</em></dt>
<dd><p>Return the value of <code>var</code> in <code>binding-lisp</code>.  When there is no such value, raises 
an error if <code>if-not-found</code> is <code>:error</code>, else returns the value of <code>if-not-found</code>.
</p></dd></dl>

<p>To apply a unifier in a target expression, use
<code>apply-substitution</code>:
</p>
<span id="index-apply_002dsubstitution-_005bshopunif_005d"></span>
<span id="Macro-shopunif_003aapply_002dsubstitution"></span><dl>
<dt id="index-apply_002dsubstitution-_005bshopunif_005d-1">Macro: <strong>apply-substitution [shopunif]</strong> <em>target substitution</em></dt>
<dd><p><code>apply-substitution</code> searches through <code>target</code>, replacing each variable
symbol with the corresponding value (if any) in <code>substitution</code>
</p></dd></dl>

<p>The following are some predicates that may be useful to a programmer using
the unifier at a low level.
</p>
<span id="index-variable_002dp-_005bshopunif_005d"></span>
<span id="Macro-shopunif_003avariable_002dp"></span><dl>
<dt id="index-variable_002dp-_005bshopunif_005d-1">Macro: <strong>variable-p [shopunif]</strong> <em>x</em></dt>
<dd><p>An alias for <code>variablep</code>, for more consistent naming.
</p></dd></dl>

<span id="index-variablep-_005bshopunif_005d"></span>
<span id="Function-shopunif_003avariablep"></span><dl>
<dt id="index-variablep-_005bshopunif_005d-1">Function: <strong>variablep [shopunif]</strong> <em>x</em></dt>
<dd><p>Is <code>x</code> a symbol representing a logical variable for SHOP&rsquo;s
theorem-prover?
</p></dd></dl>

<span id="index-anonymous_002dvar_002dp-_005bshopunif_005d"></span>
<span id="Function-shopunif_003aanonymous_002dvar_002dp"></span><dl>
<dt id="index-anonymous_002dvar_002dp-_005bshopunif_005d-1">Function: <strong>anonymous-var-p [shopunif]</strong> <em>x</em></dt>
<dd><p>Does <code>x</code> name an anonymous variable?
</p></dd></dl>

<span id="index-groundp-_005bshopunif_005d"></span>
<span id="Function-shopunif_003agroundp"></span><dl>
<dt id="index-groundp-_005bshopunif_005d-1">Function: <strong>groundp [shopunif]</strong> <em>literal</em></dt>
<dd><p>Is <code>literal</code> a ground literal?  Traverse the tree looking for a
variable.
</p></dd></dl>


<p>Finally, before unifying, it may be necessary to <em>standardize</em> the
expressions &ndash; renaming variables to be unique.
</p>
<span id="index-standardize-_005bshopunif_005d"></span>
<span id="Function-shopunif_003astandardize"></span><dl>
<dt id="index-standardize-_005bshopunif_005d-1">Function: <strong>standardize [shopunif]</strong> <em>expr &amp;optional subs</em></dt>
<dd><p>Replace all variables in <code>expr</code> with newly-generated
variables, with new names.
</p></dd></dl>

<hr>
<span id="Plan-Grapher"></span><div class="header">
<p>
Next: <a href="#Internal-Technical-Information" accesskey="n" rel="next">Internal Technical Information</a>, Previous: <a href="#The-SHOP-Unifier" accesskey="p" rel="prev">The SHOP Unifier</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Plan-Grapher-1"></span><h2 class="chapter">8 Plan Grapher</h2>

<p>In order to make the plan trees that <small>SHOP3</small> can produce more useful,
we have developed the <small>SHOP3</small> plan grapher.
</p>
<span id="index-graph_002dplan_002dtree-_005bspg_005d"></span>
<span id="Function-spg_003agraph_002dplan_002dtree"></span><dl>
<dt id="index-graph_002dplan_002dtree-_005bspg_005d-1">Function: <strong>graph-plan-tree [spg]</strong> <em>plan-forest &amp;key tree-processor graph-object</em></dt>
<dd><p>Takes a <code>shop</code> plan forest <code>(plan-tree) </code>as input, and returns a <code>cl-dot</code> graph object.
Note that the <code>plan-tree</code> name is a misnomer that reflects <code>shop</code> <code>find-plans</code> misnomer.
If you ask for plan trees from <code>shop</code>, you really get plan *forests*.
</p></dd></dl>
<span id="index-graph_002denhanced_002dplan_002dtree-_005bspg_005d"></span>
<span id="Function-spg_003agraph_002denhanced_002dplan_002dtree"></span><dl>
<dt id="index-graph_002denhanced_002dplan_002dtree-_005bspg_005d-1">Function: <strong>graph-enhanced-plan-tree [spg]</strong> <em>plan-tree &amp;key graph-object label-dependencies show-dependencies</em></dt>
<dd><p>Takes an enhanced <code>shop</code> plan tree <code>(plan-tree) </code>as input, and returns a <code>cl-dot</code> graph object.
</p></dd></dl>

<span id="index-enhanced_002dplan_002dtree_002dgraph-_005bspg_005d"></span>
<span id="Class-spg_003aenhanced_002dplan_002dtree_002dgraph"></span><dl>
<dt id="index-enhanced_002dplan_002dtree_002dgraph-_005bspg_005d-1">Class: <strong>enhanced-plan-tree-graph [spg]</strong></dt>
<dd><p>Class precedence list: <code>enhanced-plan-tree-graph, standard-object, t</code>
</p>
<p>A null class that the user subclass to
tailor display of plan graphs.
</p></dd></dl>
<span id="index-plan_002dtree_002dgraph-_005bspg_005d"></span>
<span id="Class-spg_003aplan_002dtree_002dgraph"></span><dl>
<dt id="index-plan_002dtree_002dgraph-_005bspg_005d-1">Class: <strong>plan-tree-graph [spg]</strong></dt>
<dd><p>Class precedence list: <code>plan-tree-graph, standard-object, t</code>
</p>
<p>A null class that the user subclass to
tailor display of plan graphs.
</p></dd></dl>

<hr>
<span id="Internal-Technical-Information"></span><div class="header">
<p>
Next: <a href="#Version-Differences" accesskey="n" rel="next">Version Differences</a>, Previous: <a href="#Plan-Grapher" accesskey="p" rel="prev">Plan Grapher</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Internal-Technical-Information-1"></span><h2 class="chapter">9 Internal Technical Information</h2>

<p><strong>This section has not been updated since the transition
from <small>SHOP2</small> to <small>SHOP3</small>, and its accuracy is likely
compromised.</strong> <i>Caveat lector.</i>
</p>
<p>This section presents information about the internal workings of the
<small>SHOP3</small> planning process. <strong>Important Note</strong>: This section is
primarily of interest to planning researchers and planning system
developers. Most <small>SHOP3</small> users (especially beginning users) are advised to
skip this section.
</p>
<p>The first subsection presents some key internal knowledge structures
that must be defined in order to completely specify the behavior of
<small>SHOP3</small>. The second subsection presents the formal semantics of operators
and plans. The third subsection describes an assortment of functions
within <small>SHOP3</small> that are used to accomplish those semantics.
</p><table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#Internal-Knowledge-Structures" accesskey="1">Internal Knowledge Structures</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Formal-Semantics" accesskey="2">Formal Semantics</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Key-Functions-in-SHOP3" accesskey="3">Key Functions in <small>SHOP3</small></a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr>
<span id="Internal-Knowledge-Structures"></span><div class="header">
<p>
Next: <a href="#Formal-Semantics" accesskey="n" rel="next">Formal Semantics</a>, Previous: <a href="#Internal-Technical-Information" accesskey="p" rel="prev">Internal Technical Information</a>, Up: <a href="#Internal-Technical-Information" accesskey="u" rel="up">Internal Technical Information</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Internal-Knowledge-Structures-1"></span><h3 class="section">9.1 Internal Knowledge Structures</h3>
<span id="g_t_0023internal_002dknowledge_002dstructures"></span><p>The following <small>SHOP3</small> internal knowledge structures must be defined in
order to fully specify the semantics of plan generation in <small>SHOP3</small>.
</p><table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#Substitutions" accesskey="1">Substitutions</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#States-and-Satisfiers" accesskey="2">States and Satisfiers</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr>
<span id="Substitutions"></span><div class="header">
<p>
Next: <a href="#States-and-Satisfiers" accesskey="n" rel="next">States and Satisfiers</a>, Previous: <a href="#Internal-Knowledge-Structures" accesskey="p" rel="prev">Internal Knowledge Structures</a>, Up: <a href="#Internal-Knowledge-Structures" accesskey="u" rel="up">Internal Knowledge Structures</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Substitutions-1"></span><h4 class="subsection">9.1.1 Substitutions</h4>
<span id="g_t_0023substitutions"></span>
<p><strong>Update note:</strong> <em>The variable bindings in a substitution are
no longer represented by dotted pairs. Instead, they are represented by
common lisp <strong>structures</strong> that have &lsquo;binding-var&lsquo; and
&lsquo;binding-value&lsquo; slots. So, until there has been time for a rewrite,
please read âbinding structureâ for âdotted pairâ in the following. [rpg
12 June 2018]</em>
</p>
<p>A <strong>substitution</strong> is a list of dotted pairs of the form
</p>
<blockquote>
<p><em>((x<sub>1</sub> . t<sub>1</sub>) (x<sub>2</sub> . t<sub>2</sub>) ... (x<sub>k</sub> .
t<sub>k</sub>)) </em>
</p></blockquote>
<p>where every <em>x<sub>i</sub></em> is a variable symbol and every
<em>t<sub>i</sub></em> is a term. If <em>e</em> is an expression and <em>u</em> is
the above substitution, then the <strong>substitution instance</strong>
<em>e<sup>u</sup></em> is the expression produced by starting with <em>e</em> and
replacing each occurrence of each variable symbol <em>x<sub>i</sub></em> with
the corresponding term <em>t<sub>i</sub></em>.
</p>
<p>If <em>d</em> and <em>e</em> are two expressions, then:
</p>
<ul>
<li> <em>d</em> is a <strong>generalization</strong> of <em>e</em> if <em>e</em> is a
substitution instance of <em>d</em>;

</li><li> <em>d</em> is a <strong>strict generalization</strong> of <em>e</em> if <em>d</em> is
a generalization of <em>e</em> but <em>e</em> is not a generalization of
<em>d</em>;

</li><li> <em>d</em> and <em>e</em> are <strong>equivalent</strong> if each is a
generalization of the other.

</li></ul>

<p>If <em>u</em> and <em>v</em> are two substitutions, then:
</p>
<ul>
<li> <em>u</em> is a <strong>generalization</strong> of <em>v</em> if for every
expression <em>e</em>, <em>e<sup>u</sup></em> is a generalization of
<em>e<sup>v</sup></em>;

</li><li> <em>u</em> is a <strong>strict generalization</strong> of <em>v</em> if for every
expression <em>e</em>, <em>e<sup>u</sup></em> is a strict generalization of
<em>e<sup>v</sup></em>;

</li><li> <em>u</em> and <em>v</em> are <strong>equivalent</strong> if for every expression
<em>e</em>, <em>e<sup>u</sup></em> and <em>e<sup>v</sup></em> are equivalent.

</li></ul>

<p>If <em>e</em> is an expression and <em>x<sub>1</sub>, x<sub>2</sub>, ...,
x<sub>k</sub></em> are the variable symbols in <em>e</em>, then a
<strong>standardizer</strong> for <em>e</em> is a substitution of the form
</p>
<blockquote>
<p><em>((x<sub>1</sub> . y<sub>1</sub>) (x<sub>2</sub> . y<sub>2</sub>) ... (x<sub>k</sub> .
y<sub>k</sub>)) </em>
</p></blockquote>
<p>where each <em>y<sub>i</sub></em> is a new variable symbol that is not used
anywhere else. Note that if <em>u</em> is a standardizer for <em>e</em>,
then <em>e</em> and <em>e<sup>u</sup></em> are equivalent expressions.
</p>
<p>If <em>d</em> and <em>e</em> are expressions and there is a substitution
<em>u</em> such that <em>d<sup>u</sup></em> = <em>e<sup>u</sup></em>, then <em>d</em> and
<em>e</em> are <strong>unifiable</strong> and <em>u</em> is a <strong>unifier</strong> for
them. A unifier of <em>d</em> and <em>e</em> is a <strong>most general
unifier</strong> (or <strong>mgu</strong>) of <em>d</em> and <em>e</em> if it is a
generalization of every unifier of <em>d</em> and <em>e</em>. Note that all
mgu&rsquo;s for <em>d</em> and <em>e</em> are equivalent.
</p>
<hr>
<span id="States-and-Satisfiers"></span><div class="header">
<p>
Previous: <a href="#Substitutions" accesskey="p" rel="prev">Substitutions</a>, Up: <a href="#Internal-Knowledge-Structures" accesskey="u" rel="up">Internal Knowledge Structures</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="States-and-Satisfiers-1"></span><h4 class="subsection">9.1.2 States and Satisfiers</h4>
<span id="g_t_0023states_002dand_002dsatisfiers"></span><p>A <strong>state</strong> is a list of ground atoms intended to represent some
&quot;state of the world&quot;. A conjunct <em>C</em> is a <strong>consequent</strong> of a
state <em>S</em> and an axiom list <em>X</em> if every logical expression
<em>l</em> in <em>C</em> is a consequent of <em>S</em> and <em>X</em>. A logical
expression <em>l</em> is a consequent of <em>S</em> and <em>X</em> if one of
the following is true:
</p>
<ul>
<li> <em>l</em> is an atom in <em>S</em>;

</li><li> <em>l</em> is a ground expression of the form (eval p t<sub>1</sub> t<sub>2</sub>
&hellip; t<sub>n</sub>), and the evaluation of p with arguments
t<sub>1</sub>,t<sub>2</sub>,&hellip;, t<sub>n</sub> returns a non-nil value;

</li><li> <em>l</em> is a ground expression of the form (call p t<sub>1</sub> t<sub>2</sub>
&hellip; t<sub>n</sub>), and the evaluation of p with arguments
t<sub>1</sub>,t<sub>2</sub>,&hellip;, t<sub>n</sub> returns a non-nil value;

</li><li> <em>l</em> is an expression of the form (not <em>a</em>), and the atom
<em>a</em> is not a consequent of <em>S</em> and <em>X</em>;

</li><li> <em>l</em> is an expression of the form (assign <em>v</em> <em>t</em>), where
<em>v</em> is a variable symbol and <em>t</em> is any Lisp expression. The
value of <em>t</em>, which was evaluated via a call to the Lisp evaluator,
is a substitution of <em>v</em>, i.e.<em>( v . t).</em> This term is always
a consequent of <em>S</em> and <em>X</em>;

</li><li> <em>l</em> is an expression of the form (or <em>l<sub>1</sub> l<sub>2</sub> ...
l<sub>n</sub></em>), where <em>l<sub>1</sub></em>, <em>l<sub>2</sub></em>, <em>l<sub>3</sub></em>,
..., <em>l<sub>n</sub></em> are logical expressions, and at least one
expression in this list is a consequent of <em>S</em> and <em>X;</em>

</li><li> <em>l</em> is an expression of the form (forall <em>V Y Z</em>), where
<em>Y</em> and <em>Z</em> are logical expressions and <em>V</em> is the list
of variables in <em>Y</em> such that for every satisfier <em>u</em> that
satisfies <em>Y</em> in <em>S</em> and <em>X</em>, <em>u</em> also satisfies
<em>Z</em> in <em>S</em> and <em>X</em>;

</li><li> <em>l</em> is an expression of the form (imply <em>Y Z</em>), where <em>Y</em>
and <em>Z</em> are logical expressions such that a satisfier <em>u</em>
satisfies <em>Y</em> in <em>S</em> and <em>X</em> also satisfies <em>Z</em> in
<em>S</em> and <em>X</em>;

</li><li> there exists a substitution <em>v</em> and an axiom(:- <em>a</em> n<sub>1</sub>
<em>C<sub>1</sub></em> n<sub>2</sub> <em>C<sub>2 </sub></em>... n<sub>n</sub> <em>C<sub>n</sub></em>)
in <em>X</em> such that <em>l</em> = <em>a<sup>v</sup></em> and one of the
following holds:

<ul>
<li> <em>C<sub>1</sub><sup>v</sup></em> is a consequent of <em>S</em> and <em>X</em>;

</li><li> <em>C<sub>1</sub><sup>v</sup></em> is not a consequent of <em>S</em> and <em>X</em>, but
<em>C<sub>2</sub><sup>v</sup></em> is a consequent of <em>S</em> and <em>X</em>;

</li><li> neither <em>C<sub>1</sub><sup>v</sup></em> nor <em>C<sub>2</sub><sup>v</sup></em> is a
consequent of <em>S</em> and <em>X</em>, but <em>C<sub>3</sub><sup>v</sup></em> is a
consequent of <em>S</em> and <em>X</em>;

</li><li> ...;

</li><li> none of <em>C<sub>1</sub><sup>v</sup></em>, <em>C<sub>2</sub><sup>v</sup></em>,
<em>C<sub>3</sub><sup>v</sup></em>, ..., <em>C<sub>n-1</sub><sup>v</sup></em> is a consequent of
<em>S</em> in <em>X</em>, but <em>C<sub>n</sub><sup>v</sup></em> is a consequent of
<em>S</em> and <em>X</em>.

</li></ul>

</li></ul>

<p>If <em>C</em> is a consequent of <em>S</em> and <em>X</em>, then it is a
<strong>most general consequent</strong> of <em>S</em> and <em>X</em> if there is no
strict generalization of <em>C</em> that is also a consequent of <em>S</em>
and <em>X</em>.
</p>
<p>Let <em>S</em> be a state, <em>X</em> be an axiom list, and <em>C</em> be an
ordinary conjunct. If there is a substitution <em>u</em> such that
<em>C<sup>u</sup></em> is a consequent of <em>S</em> and <em>X</em>, then we say
that <em>S</em> and <em>X</em> <strong>satisfy</strong> <em>C</em> and that <em>u</em>
is the <strong>satisfier</strong>. The satisfier <em>u</em> is a <strong>most
general satisfier</strong> (or <strong>mgs</strong>) if there is no other satisfier that
is a strict generalization of <em>u</em>. Note that <em>C</em> can have
multiple non-equivalent mgs&rsquo;s. For example, suppose <em>X</em> contains
the &quot;walking distance&quot; axiom given earlier, and <em>S</em> is the state
</p>
<div class="lisp">
<pre class="lisp">((weather-is good)
 (distance home convenience-store 1)
 (distance home supermarket 2))
</pre></div>

<p>Then for the conjunct <code>((walking-distance ?y))</code>, there are two mgs&rsquo;s from
<em>S</em> and <em>X</em>: <code>((?y . convenience-store))</code> and <code>((?y .
supermarket))</code>.
</p>
<p>Let <em>S</em> be a state, <em>X</em> be an axiom list, and <em>C</em> =
(:first <em>C&rsquo;</em> ) be a tagged conjunct. If <em>S</em> and <em>X</em>
satisfy <em>C&rsquo;</em>, then the <strong>most general satisfier</strong> for <em>C</em>
from <em>S</em> and <em>X</em> is the <em>first</em> mgs for <em>C&rsquo;</em> that
would be found by a left-to-right depth-first search. For example, if
<em>S</em> and <em>X</em> are as in the previous example, then for the
tagged conjunct (:first (walking-distance ?y)), the mgs from <em>S</em>
and <em>X</em> is ((?y . convenience-store)).
</p>
<hr>
<span id="Formal-Semantics"></span><div class="header">
<p>
Next: <a href="#Key-Functions-in-SHOP3" accesskey="n" rel="next">Key Functions in SHOP3</a>, Previous: <a href="#Internal-Knowledge-Structures" accesskey="p" rel="prev">Internal Knowledge Structures</a>, Up: <a href="#Internal-Technical-Information" accesskey="u" rel="up">Internal Technical Information</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Formal-Semantics-1"></span><h3 class="section">9.2 Formal Semantics</h3>
<span id="g_t_0023formal_002dsemantics"></span><p>Recall that a plan is a list of operator invocations with costs and that
an operator has an add list and a delete list. Informally, the meaning
of the plan is that the specified operators are performed in sequence,
incurring the specified costs. Similarly, the meaning of the operator is
that the assertions in the add list are added to the state and the
assertions in the delete list are removed from the state. The meaning of
a method is that when the method&rsquo;s precondition is satisfied, the task
specified in the method&rsquo;s head can be performed by performing each of
the tasks specified in the method&rsquo;s tail.
</p>
<p>This subsection elaborates these informal notions, presenting detailed
formal semantics of operators and plans. It is of particular use to
anyone who has a <small>SHOP3</small> domain and wishes to prove theorems (e.g.,
correctness, completeness, etc.) regarding plans generated in that
domain.
</p><table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#Semantics-of-Operators" accesskey="1">Semantics of Operators</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Semantics-of-Methods" accesskey="2">Semantics of Methods</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Semantics-of-Plans" accesskey="3">Semantics of Plans</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr>
<span id="Semantics-of-Operators"></span><div class="header">
<p>
Next: <a href="#Semantics-of-Methods" accesskey="n" rel="next">Semantics of Methods</a>, Previous: <a href="#Formal-Semantics" accesskey="p" rel="prev">Formal Semantics</a>, Up: <a href="#Formal-Semantics" accesskey="u" rel="up">Formal Semantics</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Semantics-of-Operators-1"></span><h4 class="subsection">9.2.1 Semantics of Operators</h4>
<span id="g_t_0023semantics_002dof_002doperators"></span><p><em><strong>Update note:</strong> <small>SHOP3</small> now supports PDDL operators, which
have cleaner (but more restricted) semantics. Their semantics is
discussed in many treatments of the PDDL specification. We hope to add
an explanation later. See Chapter</em> <em>7 for discussion of PDDL
support in <small>SHOP3</small>. [12 June 2018 &ndash; rpg]</em>
</p>
<p>The intent of an operator is to specify that the task <em>h</em> can be
accomplished at a cost of <em>c</em>, by modifying the current state of
the world to remove every logical atom in <em>D</em> and add every logical
atom in <em>A</em> if <em>P</em> is satisfied in the current state. In order
to prevent plans from being ambiguous, there should be at most one
operator for each primitive task symbol. <em>Furthermore, whenever an
action is inserted into a plan, it must be <strong>ground</strong> &ndash; there must
be no unbound parameters in its task head. [Inserted 12 June 2018 based
on discussions with Ugur &ndash; rpg]</em>
</p>
<p>Let <em>S</em> be a state, <em>X</em> be the list of axioms, <em>L</em> be the
list of protected conditions, <em>t</em> be a primitive task atom, and
<em>o</em> be a planning operator whose head, precondition, delete list,
add list, and cost are <em>h</em>, <em>P</em>, <em>D</em>, <em>A</em>, and
<em>c</em>, respectively. Suppose that there is an mgu <em>u</em> for
<em>t</em> and <em>h</em>, such that <em>h<sup>u</sup></em> is ground, that none of
the ground atoms in <em>D<sup>u</sup></em> are in the list of protected
conditions, and <em>P<sup>u</sup></em> is satisfied in S. Then we say that
<em>o<sup>u</sup></em> is <strong>applicable</strong> to <em>t</em>, and that
<em>h<sup>u</sup></em> is a <strong>simple plan</strong> for <em>t</em>. If <em>S</em> is a
state, then the state and the protection list produced by executing
<em>o<sup>u</sup></em> (or equivalently, <em>h<sup>u</sup></em>) in <em>S</em> and
<em>L</em> is the new state:
</p>
<p>(<em>S&rsquo;</em>,<em>L&rsquo;</em>) = result(<em>S,L,h<sup>u</sup></em>) =
result(<em>S,L,o<sup>u</sup></em>) = (<em>S - D<sup>u</sup></em>) U <em>A<sup>u</sup>.</em>
</p>
<p>where <em>S&rsquo;</em> and <em>L&rsquo;</em> are obtained by modifying the current
state of the world and the list of protected conditions as follows:
</p>
<ul>
<li> remove every logical atom in <em>D<sup>u</sup></em> from the current state;

</li><li> remove every protection condition in <em>D<sup>u</sup></em> from the list of
protected conditions;

</li><li> for every expression (forall V Y Z) in <em>D<sup>u</sup></em> and every
satisfier <em>v</em> such that <em>S</em> and <em>X</em> satisfy
<em>Y<sup>v</sup></em>, remove every logical atom in <em>Z<sup>u</sup></em> from the
current state;

</li><li> for every expression (forall V Y Z) in <em>D<sup>u</sup></em> and every
satisfier <em>v</em> such that <em>S</em> and <em>X</em> satisfy
<em>Y<sup>v</sup></em>,, remove every protection condition in <em>Z<sup>u</sup></em>
from the list of protected conditions;

</li><li> add every logical atom in <em>A<sup>u</sup></em> to the current state;

</li><li> add every protection condition in <em>A<sup>u</sup></em> to the list of
protected conditions;

</li><li> for every expression (forall V Y Z) in <em>A<sup>u</sup></em> and every
satisfier <em>v</em> such that <em>S</em> and <em>X</em> satisfy
<em>Y<sup>v</sup></em>, add every logical atom in <em>Z<sup>u</sup></em> to the
current state;

</li><li> for every expression (forall V Y Z) in <em>A<sup>u</sup></em> and every
satisfier <em>v</em> such that <em>S</em> and <em>X</em> satisfy
<em>Y<sup>v</sup></em>, add every protection condition in <em>Z<sup>u</sup></em> to
the list of protected conditions.

</li></ul>

<p>Here is an example:
</p>
<table>
<tr><td><em>S</em></td><td><code>((has-money john 40) (has-money mary 30))</code></td></tr>
<tr><td><em>T</em></td><td><code>(!set-money john 40 35)</code></td></tr>
<tr><td><em>O</em></td><td><div class="lisp">
<pre class="lisp">(:operator (!set-money ?person ?old ?new)
    ((has-money ?person ?old))
    ((has-money ?person ?old))
    ((has-money ?person ?new)))
</pre></div></td></tr>
<tr><td><em>U</em></td><td><code>((?person . john) (?old . 40) (?new . 35))</code></td></tr>
<tr><td><em>o<sup>u</sup></em></td><td><div class="lisp">
<pre class="lisp">(:operator (!set-money john 40 35)
    ((has-money john 40))
    ((has-money john 40))
    ((has-money john 35)))
</pre></div></td></tr>
<tr><td><em>h<sup>u</sup></em></td><td><code>(!set-money john 40 35)</code></td></tr>
<tr><td>Result(<em>S,h<sup>u</sup></em>)

<p>result(<em>S,o<sup>u</sup></em>)
 </p></td><td><code>((has-money john 35) (has-money mary 30) )</code>

<p><code>((has-money john 35) (has-money mary 30) )</code>
</p></td></tr>
</table>

<p>Here is an example using the forall keyword
</p>
<table>
<tr><td><em>S</em></td><td><code>((location l1) (location l2) (location l3) (truck-at truck1 l1))</code></td></tr>
<tr><td><em>T</em></td><td><code>(!clear-locations)</code></td></tr>
<tr><td><em>O</em></td><td><div class="lisp">
<pre class="lisp"> (:operator (!clear-locations)
    ((forall (?l)
        ((location ?l)
        (not (truck-at ?t ?l)))
    ((location ?l))))
    ())
</pre></div></td></tr>
<tr><td><em>U</em></td><td>()</td></tr>
<tr><td><em>o<sup>u</sup></em></td><td><div class="lisp">
<pre class="lisp">(:operator (!clear-locations)
    (forall (?l)
        ((location ?l)
         (not (truck-at ?t ?l))))
     ((location ?l))
    ())
</pre></div></td></tr>
<tr><td><em>h<sup>u</sup></em> =</td><td><code>(!clear-locations)</code></td></tr>
<tr><td>Result(<em>S,h<sup>u</sup></em>)</td><td><code>((location l1) (truck-at truck1 l1))</code></td></tr>
<tr><td>result(<em>S,o<sup>u</sup></em>)</td><td><code>((location l1) (truck-at truck1 l1))</code></td></tr>
</table>

<hr>
<span id="Semantics-of-Methods"></span><div class="header">
<p>
Next: <a href="#Semantics-of-Plans" accesskey="n" rel="next">Semantics of Plans</a>, Previous: <a href="#Semantics-of-Operators" accesskey="p" rel="prev">Semantics of Operators</a>, Up: <a href="#Formal-Semantics" accesskey="u" rel="up">Formal Semantics</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Semantics-of-Methods-1"></span><h4 class="subsection">9.2.2 Semantics of Methods</h4>
<span id="g_t_0023semantics_002dof_002dmethods"></span><p>The purpose of a method is to specify the following:
</p>
<ul>
<li> If the current state of the world satisfies <em>C<sub>1</sub></em>, then
<em>h</em> can be accomplished by performing the tasks in <em>T<sub>1</sub></em>
in the order given;

</li><li> otherwise, if the current state of the world satisfies <em>C<sub>2</sub></em>,
then <em>h</em> can be accomplished by performing the tasks in
<em>T<sub>2</sub></em> in the order given;

</li><li> ...;

</li><li> otherwise, if the current state of the world satisfies <em>C<sub>k</sub></em>,
then <em>h</em> can be accomplished by performing the tasks in
<em>T<sub>k</sub></em> in the order given.

</li></ul>

<p>Let <em>S</em> be a state, <em>X</em> be an axiom list, <em>t</em> be a task
atom (which may or may not be ground), and <em>m</em> be the method
(:method <em>h</em> <em>C<sub>1</sub></em> <em>T<sub>1</sub></em> <em>C<sub>2</sub></em>
<em>T<sub>2</sub></em> ... <em>C<sub>k</sub></em> <em>T<sub>k</sub></em>). Suppose there is
an mgu <em>u</em> that unifies <em>t</em> with <em>h</em>; and suppose that
<em>m</em> has a precondition <em>C<sub>i</sub></em> such that <em>S</em> and
<em>X</em> satisfy <em>C<sub>i</sub><sup>u</sup></em> (if there is more than one such
precondition, then let <em>C<sub>i</sub></em> be the first such precondition).
Then we say that <em>m</em> is <strong>applicable</strong> to <em>t</em> in <em>S</em>
and <em>X</em>, with the <strong>active precondition</strong> <em>C<sub>i</sub></em> and
the <strong>active tail</strong> <em>T<sub>i</sub></em>. Then the result of applying
<em>m</em> to <em>t</em> is the following set of task lists:
</p>
<blockquote>
<p><em>R</em> = {<em>Call</em>((<em>T<sub>i</sub><sup>u</sup></em>)<em><sup>v</sup></em>):
<em>v</em> is an mgs for <em>C<sub>i</sub><sup>u</sup></em> from <em>S</em> and
<em>X</em>}
</p></blockquote>
<p>where C<em>all</em> is <small>SHOP3</small>&rsquo;s evaluation function (the function that
evaluates the values of the call-terms in the form (call f t<sub>1</sub>
t<sub>2</sub> .. t<sub>n</sub>)). Each task list <em>r</em> in <em>R</em> is called a
<strong>simple reduction</strong> of <em>t</em> by <em>m</em> in <em>S</em> and
<em>X.</em> Here is an example:
</p>
<table>
<tr><td><em>S</em></td><td><code>((has-money john 40) (has-money mary 30))</code></td></tr>
<tr><td><em>X</em></td><td><code>nil</code></td></tr>
<tr><td><em>t</em></td><td><code>(transfer-money john mary 5)</code></td></tr>
<tr><td><em>M </em></td><td><div class="lisp">
<pre class="lisp"> (:method (transfer-money ?p1 ?p2 ?amount)
    ((has-money ?p1 ?m1)
     (has-money ?p2 ?m2)
     (call &gt;= ?m1 ?amount))
    (:ordered (:task !set-money ?p1 ?m1 (call - ?m1 ?amount))
                   (:task !set-money ?p2 ?m2 (call + ?m2 ?amount))))
</pre></div></td></tr>
<tr><td><em>u</em></td><td><code>((?p1 . john) (?p2 . mary) (?amount . 5))</code></td></tr>
<tr><td><em>h<sup>u</sup></em></td><td><code>(transfer-money john mary 5)</code></td></tr>
<tr><td><em>C<sub>1</sub><sup>u</sup></em></td><td><div class="lisp">
<pre class="lisp">((has-money john ?m1)
 (has-money mary ?m2)
 (call &gt;= ?m1 5))
</pre></div></td></tr>
<tr><td><em>T<sub>1</sub><sup>u</sup></em></td><td><div class="lisp">
<pre class="lisp">(:ordered
     (:task !set-money john ?m1 (call - ?m1 5))
     (:task !set-money mary ?m2 (call + ?m2 5)))
</pre></div></td></tr>
<tr><td><em>v</em></td><td><code>((?m1 . 40) (?m2 . 30))</code></td></tr>
<tr><td>(<em>C<sub>1</sub><sup>u</sup></em>)<em><sup>v</sup></em></td><td><div class="lisp">
<pre class="lisp">((has-money john 40)
  (has-money mary 30)
  (call &gt;= 40 30))
</pre></div></td></tr>
<tr><td>(<em>T<sup>u</sup></em>)<em><sup>v</sup></em></td><td><div class="lisp">
<pre class="lisp">(:ordered
     (:task !set-money john 40 (call - 40 5))
     (:task !set-money mary 30 (call + 30 5)))
</pre></div></td></tr>
<tr><td><em>call</em>((<em>T<sup>u</sup></em>)<em><sup>v</sup></em>)</td><td><div class="lisp">
<pre class="lisp">(:ordered
     (:task !set-money john 40 35)
     (:task !set-money mary 30 35))
</pre></div></td></tr>
</table>

<hr>
<span id="Semantics-of-Plans"></span><div class="header">
<p>
Previous: <a href="#Semantics-of-Methods" accesskey="p" rel="prev">Semantics of Methods</a>, Up: <a href="#Formal-Semantics" accesskey="u" rel="up">Formal Semantics</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Semantics-of-Plans-1"></span><h4 class="subsection">9.2.3 Semantics of Plans</h4>
<span id="g_t_0023semantics_002dof_002dplans"></span><p>Recall that a planning domain contains axioms, operators, and methods,
and that a planning problem is a 4-tuple (<em>S,M,L,D</em>), where
<em>S</em> is a state, <em>M</em> is a task list, <em>L</em> is a protection
list, and <em>D</em> is a domain representation.&nbsp; Let <em>T</em> be the
list of tasks in <em>M</em> that have no predecessor (i.e., those tasks
can be performed at this time if they are applicable).&nbsp;&nbsp; If <em>t</em>
is a task in <em>T,</em> and <em>S</em> is a state, then a
<strong>reduction</strong> of <em>t</em> in <em>S</em> and D with respect to
<em>M</em> and <em>L</em> that results in a new planning problem
(<em>S&rsquo;,M&rsquo;,L&rsquo;,D)&nbsp;</em> is defined as follows:
</p>
<blockquote>
<p><strong>if</strong> <em>t</em> is a primitive task, <strong>then</strong>
</p>
<p>(<em>S&rsquo;</em>, <em>L&rsquo;</em>) = result(<em>S,L,t</em>);
</p>
<p><em>M&rsquo;</em> = the task list produced by removing <em>t</em> from <em>M</em>
</p>
<p><strong>else</strong> <em>t</em> is a compound task, <strong>then</strong>
</p>
<p><em>S&rsquo;</em> = <em>S</em>;
</p>
<p><em>L&rsquo;</em> = <em>L</em>;
</p>
<p>Suppose <em>m</em> is an applicable method to <em>t</em> in <em>S</em>, with
unifier <em>u,</em> the active precondition <em>C<sub>i</sub></em> and the active
tail <em>T<sub>i</sub>.</em>
</p>
<p><em>M&rsquo; =</em> the task list produced by replace <em>t</em> with
<em>T<sub>i</sub><sup>u</sup></em> in <em>M</em>
</p></blockquote>
<p><strong>endif</strong>
</p>
<p>If <em>P</em> = (<em>p</em><sub>1</sub> <em>p</em><sub>2</sub> ... <em>p<sub>n</sub></em>) is a
plan, then we say that <em>P</em> <strong>solves</strong> (<em>S,M,L,D</em>), or
equivalently, that <em>P</em> achieves <em>M</em> from <em>S</em> in <em>D</em>
(we will omit the phrase &quot;in <em>D</em>&quot; if the identity of <em>D</em> is
obvious) in any of the following cases:
</p>
<p><strong>Case 1</strong>.
</p>
<p>both <em>M</em> and <em>P</em> are empty.
</p>
<p><strong>Case 2</strong>.
</p>
<blockquote>
<p><em>T</em> = (<em>t</em><sub>1</sub> <em>t</em><sub>2</sub> ... <em>t<sub>k</sub></em>) is a
list of tasks in <em>M</em> that have no predecessor for which there is a
task <em>t</em><sub>i</sub> that has the <code>:immediate</code> keyword and is applicable
to the current state <em>S</em>.&nbsp; Let (<em>S&rsquo;, M&rsquo;, L&rsquo;</em>) =
reduction(<em>t<sub>i</sub>, S, M, L</em>).&nbsp; We say <em>P</em>
<strong>solves</strong>(<em>S,M,L,D</em>) if either of the following is true.
</p></blockquote>
<ul>
<li> <em>t<sub>i</sub></em> is primitive and&nbsp; <em>p<sub>1</sub> = t<sub>i</sub></em> and
(<em>p<sub>2</sub>&nbsp; p<sub>3</sub> ... p<sub>n</sub></em>) solves (<em>S&rsquo;, M&rsquo;, L&rsquo;, D</em>)

</li><li> <em>t<sub>i</sub></em> is not primitive, and <em>P</em> solves (<em>S&rsquo;, M&rsquo;, L&rsquo;,
D</em>)

</li></ul>

<p><strong>Case 3.</strong>
</p>
<blockquote>
<p><em>T</em> = (<em>t</em><sub>1</sub> <em>t</em><sub>2</sub> ... <em>t<sub>k</sub></em>) is a
list of tasks in <em>M</em> that have no predecessor, where
<em>t</em><sub>i</sub> is a task in <em>T</em> that&rsquo;s applicable to the current
state <em>S</em>.&nbsp; Let (<em>S&rsquo;, M&rsquo;, L&rsquo;</em>) = reduction(<em>t<sub>i</sub>, S,
M, L</em>).&nbsp; We say <em>P</em> <strong>solves</strong> (<em>S,M,L,D</em>) if either of
the following is true.
</p></blockquote>
<ul>
<li> <em>t<sub>i</sub></em> is primitive and <em>p<sub>1</sub> = t<sub>i</sub></em> and
(<em>p<sub>2</sub>&nbsp; p<sub>3</sub> ... p<sub>n</sub></em>) solves (<em>S&rsquo;, M&rsquo;, L&rsquo;, D</em>)

</li><li> <em>t<sub>i</sub></em> is not primitive and <em>P</em> solves (<em>S&rsquo;, M&rsquo;, L&rsquo;,
D</em>)

</li></ul>

<p>The planning problem (<em>S,M,L,D</em>) is <strong>solvable</strong> if there is a
plan that solves it. For example, suppose that
</p>
<table>
<tr><td>S</td><td><code>nil</code></td></tr>
<tr><td>M</td><td><code> ((:ordered (:task do-both op1 op2)))</code></td></tr>
<tr><td>T</td><td><code>((:task do-both op1 op2))</code></td></tr>
<tr><td>L</td><td>nil</td></tr>
<tr><td>D</td><td><div class="lisp">
<pre class="lisp">(
    (:operator (!do ?operation) nil ((did ?operation)))
    (:method (do-both ?x ?y)
           nil
           (:ordered
               (:task !do ?x)
               (:task !do ?y)))
    (:method (do-both ?x ?y)
        nil
        (:ordered (:task !do ?y)
               (:task !do ?x))))
</pre></div></td></tr>
<tr><td>P<sub>1</sub></td><td><code>((do op1) 1 (do op2) 1)</code></td></tr>
<tr><td>P<sub>2</sub></td><td><code>((do op2) 1 (do op1) 1)</code></td></tr>
</table>

<p>Then P<sub>1</sub> and P<sub>2</sub> are all of the plans that solve
(<em>S,M,L,D</em>).
</p>
<hr>
<span id="Key-Functions-in-SHOP3"></span><div class="header">
<p>
Previous: <a href="#Formal-Semantics" accesskey="p" rel="prev">Formal Semantics</a>, Up: <a href="#Internal-Technical-Information" accesskey="u" rel="up">Internal Technical Information</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Key-Functions-in-SHOP3-1"></span><h3 class="section">9.3 Key Functions in <small>SHOP3</small></h3>
<p>Below are some important functions in the Lisp implementation of <small>SHOP3</small>.
They should be of interest to anyone who wishes to modify <small>SHOP3</small> or to
directly access internal capabilities of <small>SHOP3</small>. Pseudocode algorithms
for the main planning functions of <small>SHOP3</small> are also presented.
</p>
<div class="lisp">
<pre class="lisp">(apply-substitution e u)
</pre></div>

<p><em>e</em> is an expression and <em>u</em> is a substitution. The function
returns <em>e<sup>u</sup></em>.
</p>
<p>(compose-substitutions u v)
</p>
<blockquote>
<p>If <em>u</em> and <em>v</em> are substitutions, then this function returns a
substitution <em>w</em> such that for every expression <em>e</em>,
<em>e<sup>w</sup></em> = (<em>e<sup>u</sup></em>)<em><sup>v</sup></em>.
</p></blockquote>
<p>(standardizer e)
</p>
<p>This function returns a standardizer for <em>e</em>.
</p>
<p>(standardize e)
</p>
<p>This function is equivalent to (apply-substitution e (standardizer e)).
</p>
<p>(unify d e)
</p>
<blockquote>
<p>This procedure returns an mgu for the expressions <em>d</em> and <em>e</em>
if they are unifiable, and returns fail otherwise.
</p></blockquote>
<p>(find-satisfiers C S &amp;optional just-one)
</p>
<blockquote>
<p>If <em>C</em> is a conjunct and <em>S</em> is a state, then this function
returns a list of mgs&rsquo;s, one for every most general instance of <em>C</em>
that is satisfied by <em>S</em>. If the optional argument <em>just-one</em>
is not nil, then the function returns the first mgs it finds, rather
than all of them. Calling (find-satisfiers C S) is roughly equivalent to
calling the following (simplified) pseudocode:
</p>
<p><strong>procedure</strong> find-satisfiers(C, S)
</p>
<p><strong>if</strong> C is empty <strong>then return</strong> {nil}
</p>
<p>l = the first logical atom in C; B = the remaining logical atoms in C
</p>
<p>answers = nil
</p>
<p><strong>if</strong> l is an expression of the form (not e) <strong>then</strong>
</p>
<p><strong>if</strong> find-satisfiers(e, S, nil) = nil <strong>then</strong>
</p>
<p><strong>return</strong> find-satisfiers(B, S)
</p>
<p><strong>else</strong>
</p>
<p><strong>return</strong> nil
</p>
<p><strong>end if</strong>
</p>
<p><strong>else if</strong> l is an expression of the form (eval e) <strong>then</strong>
</p>
<p><strong>if</strong> eval(e) is not nil <strong>then</strong>
</p>
<p><strong>return</strong> find-satisfiers(B, S)
</p>
<p><strong>else</strong>
</p>
<p><strong>return</strong> nil
</p>
<p><strong>end if</strong>
</p>
<p><strong>else if</strong> l is an expression of the form (or p<sub>1</sub> p<sub>2</sub>
... p<sub>n</sub>) <strong>then</strong>
</p>
<p><strong>for</strong> every unifier u that unifies any p<sub>i</sub> with l
</p>
<p><strong>for</strong> every v in find-satisfiers(B<sup>u</sup>, S)
</p>
<p><strong>insert</strong> compose-substitutions(u,v) into answers
</p>
<p><strong>end for</strong>
</p>
<p><strong>end for</strong>
</p>
<p><strong>else if</strong> l is an expression of the form (imply C<sub>1</sub>
C<sub>2</sub>) <strong>then</strong>
</p>
<p>mgu = find-satisfiers(C<sub>1</sub>, S)
</p>
<p><strong>if</strong> mgu is null or there exist a unifier u in mgu such that
</p>
<p>find-satisfiers(C<sub>2</sub><sup>u</sup>, S) is not equal to nil <strong>then</strong>
</p>
<p><strong>return</strong> find-satisfiers(B, S)
</p>
<p><strong>else</strong>
</p>
<p><strong>return</strong> nil
</p>
<p><strong>end if</strong>
</p>
<p><strong>else if</strong> l is an expression of the form
</p>
<p>(forall variables bounds conditions) <strong>then</strong>
</p>
<p>mgu = find-satisfiers(bounds, S)
</p>
<p><strong>if</strong> mgu is null or for every unifier u in mgu,
</p>
<p>find-satisfiers(conditions<sup>u</sup>, S) is not equal to nil <strong>then</strong>
</p>
<p><strong>return</strong> find-satisfiers(B, S)
</p>
<p><strong>else</strong>
</p>
<p><strong>return</strong> nil
</p>
<p><strong>end if</strong>
</p>
<p><strong>else</strong>
</p>
<p><strong>for</strong> every atom s in S that unifies with l
</p>
<p><strong>let</strong> u be the unifier
</p>
<p><strong>for</strong> every v in find-satisfiers(B<sup>u</sup>, S)
</p>
<p><strong>insert</strong> compose-substitutions(u,v) into answers
</p>
<p><strong>end for</strong>
</p>
<p><strong>end for</strong>
</p>
<p><strong>for</strong> every axiom x in *axioms* whose head unifies with l
</p>
<p><strong>let</strong> u be the unifier
</p>
<p><strong>if</strong> tail(x) contains a conjunct D such that
</p>
<p>find-satisfiers(append(D<sup>u</sup>, B<sup>u</sup>), S) is not nil <strong>then</strong>
</p>
<p><strong>let</strong> D be the first such conjunct
</p>
<p><strong>for</strong> every v in find-satisfiers(append(D<sup>u</sup>, B<sup>u</sup>), S)
</p>
<p><strong>insert</strong> compose-substitutions(u, v)
</p>
<p>into answers
</p>
<p><strong>end for</strong>
</p>
<p><strong>end if</strong>
</p>
<p><strong>end for</strong>
</p>
<p><strong>end if</strong>
</p>
<p><strong>return</strong> answers
</p>
<p><strong>end</strong> find-satisfiers
</p>
<p>In this pseudo-code, <code>*axioms*</code> is an internal variable of <small>SHOP3</small>. It holds
the list of the axioms defined for the domain under consideration.
</p></blockquote>
<p><code>(apply-method S t m)</code>
</p>
<p>If <em>S</em> is a state, <em>t</em> is a task, and 
<em>m</em> = <code>(:method h C<sub>1</sub> T<sub>1</sub> C<sub>2</sub> T<sub>2</sub> ... C<sub>k</sub> T<sub>k</sub>) </code>is a method,
then this function does the following:
</p>
<ul>
<li> If <em>m</em> is not applicable to <em>t</em> in <em>S</em>, then the function
returns the symbol <code>FAIL</code>.

</li><li> If <em>m</em> is applicable to <em>t</em> in <em>S</em> and <em>C<sub>i</sub></em> is
the active precondition, then the function returns a list of all simple
reductions of <em>T<sub>i</sub></em>, one for each satisfier of <em>C<sub>i</sub></em>
in <em>S</em>.

</li></ul>

<p><code>(apply-operator S t o)</code>
</p>
<p>If <em>S</em> is a state, <em>t</em> is a task, and <em>o</em> is an operator,
then this function does the following:
</p>
<ul>
<li> If there is an mgu <em>u</em> for <em>o</em> and <em>t</em>, then it returns
the state produced by executing <em>o<sup>u</sup></em> in <em>S</em>.

</li><li> Otherwise, it returns FAIL.
</li></ul>

<p><code>(find-plans problem &amp;key which verbose pshort gc pp state plan-tree optimize-cost time-limit explanation)</code>
</p>
<p>This function implements the <small>SHOP3</small> planning algorithm. For more about
the arguments to and use of this function, see <a href="#find_002dplans">find-plans</a>. A brief
overview of the algorithm for this function is presented here. Calling
find-plans is roughly equivalent to calling the following pseudocode,
where <em>S</em> is the current state, <em>T</em> is a partially ordered set
of tasks, and <em>L</em> is a list of protected conditions:
</p>
<p><strong>procedure</strong> find-plans (<em>S,T,L</em>)
</p>
<p><strong>if</strong> <em>T</em> is empty <strong>then</strong>
</p>
<p><strong>return</strong> NIL
</p>
<p><strong>endif</strong>
</p>
<p>nondeterministically choose a task <em>t</em> in <em>T</em> that has no
predecessors
</p>
<p>&lt;<em>r,R&rsquo;</em>&gt; = reduction (<em>S</em>,<em>t</em>)
</p>
<p><strong>if</strong> <em>r</em> = FAIL <strong>then </strong>
</p>
<p><strong>return</strong> FAIL
</p>
<p><strong>endif</strong>
</p>
<p>nondeterministically choose an operator instance <em>o</em> applicable to
<em>r</em> in <em>S</em>
</p>
<p><em>S&rsquo;</em> = the state produced from <em>S</em> by applying <em>o</em> to
<em>r</em>
</p>
<p><em>L&rsquo;</em> = the protection list produced from <em>L</em> by applying
<em>o</em> to <em>r</em>
</p>
<p><em>T&rsquo;</em> = the partially ordered set of tasks produced from <em>T</em> by
replacing <em>t</em> with <em>R&rsquo;</em>
</p>
<p><em>P</em> = find-plans (<em>S&rsquo;</em>,<em>T&rsquo;</em>,<em>L&rsquo;</em>)
</p>
<p><strong>return</strong> cons(<em>o</em>,<em>P</em>)
</p>
<p><strong>end</strong> find-plans
</p>
<p><strong>procedure</strong> reduction (<em>S,t</em>)
</p>
<p><strong>if</strong> <em>t</em> is a primitive task <strong>then </strong>
</p>
<p><strong>return</strong> &lt;<em>t</em>,NIL&gt;
</p>
<p><strong>else if</strong> no method is applicable to <em>t</em> in <em>S</em>
<strong>then</strong>
</p>
<p><strong>return</strong> &lt;FAIL,NIL&gt;
</p>
<p><strong>endif</strong>
</p>
<p>nondeterministically let <em>m</em> be any method applicable to <em>t</em>
in <em>S</em>
</p>
<p><em>R</em> = the decomposition (partially ordered set of tasks) produced
by <em>m</em> from <em>t</em>
</p>
<p><em>r</em> = any task in <em>R</em> that has no predecessors
</p>
<p>&lt;<em>r&rsquo;,R&rsquo;</em>&gt; = reduction (<em>S</em>,<em>r</em>)
</p>
<p><strong>if</strong> <em>r&rsquo;</em> = FAIL <strong>then </strong>
</p>
<p><strong>return</strong> &lt;FAIL,NIL&gt;
</p>
<p><strong>endif</strong>
</p>
<p><em>R&rdquo;</em> = the partially ordered set of tasks produced from <em>R</em>
by replacing <em>r</em> with <em>R&rsquo;</em>
</p>
<p><strong>return</strong> &lt;<em>r</em>&rsquo;<strong>,</strong><em>R&rdquo;</em>&gt;
</p>
<p><strong>end</strong> reduction
</p>
<p><code>(defdomain <em>domain-name D</em>)</code>
</p>

<p>This macro gives the name <em>domain-name</em> to planning domain
<em>D</em>. (More specifically, what it does is to store <em>D</em>&rsquo;s
axioms, operators, and methods on <em>domain-name</em>&rsquo;s property list.)
</p>
<p><code>(defproblem <em>problem-name domain-name S T</em>)</code>
</p>

<p>This macro gives the name <em>problem-name</em> to the planning problem
<em>(S,T,D)</em>, where <em>D</em> is the planning domain whose name is
<em>domain-name</em>. (More specifically, what it does is to store
<em>S</em>, <em>T</em>, and <em>domain-name</em> on <em>problem-name</em>&rsquo;s
property list.)
</p>
<div class="lisp">
<pre class="lisp">(def-problem-set <em>set-name list-of-problems</em>)
</pre></div>



<p>This macro gives the name <em>set-name</em> to the set of planning
problems in <em>list-of-problems</em>. (More specifically, what it does is
to store <em>list-of-problems</em> on <em>set-name</em>&rsquo;s property list.)
</p>
<p>Note that for backwards compatibility, <small>SHOP3</small> also accepts the forms
make-domain, make-problem, and make-problem-set, which were employed in
SHOP 1.x, using the same arguments as defdomain, defproblem, and
def-problem-set. The difference between the make-X and def-X forms is
that in the latter case since the form itself is a macro, the arguments
are not evaluated. This changes the syntax one uses. Thus in a SHOP 1.x
domain one might define a problem as
</p>
<div class="lisp">
<pre class="lisp">(make-problem â<var>problem-name</var> â<var>domain-name</var>
    â<var>(list of state atoms)</var>
    â<var>(list of tasks to be accomplished)</var>)
</pre></div>

<p>whereas in <small>SHOP3</small> the syntax becomes
</p>
<div class="lisp">
<pre class="lisp">(defproblem problem-name domain-name
    (list of state atoms)
    (list of tasks to be accomplished))
</pre></div>

<p>where the arguments are all quoted in the SHOP 1.x make-problem
function, they are unquoted when using the <small>SHOP3</small> defproblem macro.
</p>
<p><code>(print-axioms &amp;optional <var>name</var>)</code>
</p>
<p>This function prints a list of the axioms for the domain whose name is
<em>name</em>; defaults to the most recently defined domain.
</p>
<p><code>(print-operators &amp;optional <var>name</var>)</code>
</p>
<p>This function prints a list of the operators for the domain whose name
is <em>name</em>; defaults to the most recently defined domain.
</p>
<p><code>(print-methods &amp;optional <var>name</var>)</code>
</p>
<p>This function prints a list of the methods for the domain whose name is
<em>name</em>; defaults to the most recently defined domain.
</p>
<p><code>(get-state <var>name</var>)</code>
</p>
<p>This function returns the initial state for the problem whose name is
<var>name</var>.
</p>
<p><code>(get-tasks <var>name</var>)</code>
</p>
<p>This function returns the list of tasks for the problem whose name is
<var>name</var>.
</p>
<p><code>(get-problems <var>name</var>)</code>
</p>
<p>This function returns the list of problem names for the problem set
whose name is <var>name</var>.
</p>
<p><code>(do-problems <var>name-or-list</var> &amp;rest keywords)</code>
</p>
<p><var>name-or-list</var> should be either a list of problem names or the name
of a problem set. This function runs <code>find-plans</code> on each planning problem
specified by the list or problem set, and then returns nil. The keywords
are simply passed on to find-plans.
</p>


<hr>
<span id="Version-Differences"></span><div class="header">
<p>
Next: <a href="#General-Notes-on-SHOP3" accesskey="n" rel="next">General Notes on SHOP3</a>, Previous: <a href="#Internal-Technical-Information" accesskey="p" rel="prev">Internal Technical Information</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Differences-between-SHOP-1_002ex_002c-SHOP2-and-SHOP3"></span><h2 class="chapter">10 Differences between SHOP 1.x, SHOP2 and <small>SHOP3</small></h2>

<p>The differences between <small>SHOP3</small> and SHOP 1.x can be grouped in two sets:
syntactic changes in the domain definitions and differences in
functionality.
</p>
<p><em><strong>Note:</strong> This section has not been updated since the
extensive modifications were made to <small>SHOP3</small> (since as time goes by, the
number of people who would find it useful dwindles more and more). It
provides an effective description of the difference between SHOP1 and
the <strong>original</strong></em> <em><small>SHOP3</small> syntax, but does not reflect updates
in the past decade. This section should probably be removed. &ndash; rpg
December 22, 2017</em>
</p><table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#SHOP-1x-Syntax-Comparison" accesskey="1">SHOP 1x Syntax Comparison</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#SHOP-1x-Functionality-Comparison" accesskey="2">SHOP 1x Functionality Comparison</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr>
<span id="SHOP-1x-Syntax-Comparison"></span><div class="header">
<p>
Next: <a href="#SHOP-1x-Functionality-Comparison" accesskey="n" rel="next">SHOP 1x Functionality Comparison</a>, Previous: <a href="#Version-Differences" accesskey="p" rel="prev">Version Differences</a>, Up: <a href="#Version-Differences" accesskey="u" rel="up">Version Differences</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="SHOP-1_002ex-Syntax-Comparison"></span><h3 class="section">10.1 SHOP 1.x Syntax Comparison</h3>
<span id="g_t_0023shop_002d1_002ex_002dsyntax_002dcomparison"></span><p>The table below gives examples of SHOP 1.x syntax, comparing it to the
syntax used in <small>SHOP3</small>:
</p>
<table>
<tr><td><strong><small>SHOP1</small> syntax</strong></td><td><strong><small>SHOP2</small> Syntax</strong></td></tr>
<tr><td>(make-domain &rsquo;travel

<p>&rsquo;(
</p>
<p>(:- (have-taxi-fare ?distance)
</p>
<p>((have-cash ?m)
</p>
<p>(eval (&gt;= ?m (+ 1.5 ?distance)))))
</p>
<p>(:- (walking-distance ?u ?v)
</p>
<p>((weather-is&rsquo;good)<br>
(distance ?u ?v ?w)<br>
(eval (&lt;= ?w 3)))
</p>
<p>((distance ?u ?v ?w)
</p>
<p>(eval (&lt;= ?w 0.5))))
</p>
<p>(:method (pay-driver ?fare)
</p>
<p>((have-cash ?m)<br>
(eval (&gt;= ?m ?fare)))
</p>
<p>&lsquo;((!set-cash ?m ,(- ?m ?fare))))
</p>
<p>(:method (travel-to ?q)
</p>
<p>((at ?p) (walking-distance ?p ?q))
</p>
<p>&rsquo;((!walk ?p ?q)))
</p>
<p>(:method (travel-to ?y)
</p>
<p>((at ?x) (at-taxi-stand ?t ?x)
</p>
<p>(distance ?x ?y ?d) (have-taxi-fare ?d))<br>
&lsquo;((!hail ?t ?x) (!ride ?t ?x ?y)
</p>
<p>(pay-driver ,(+ 1.50 ?d)))
</p>
<p>((at ?x) (bus-route ?bus ?x ?y))
</p>
<p>&lsquo;((!wait-for ?bus ?x) (pay-driver 1.00)<br>
(!ride ?bus ?x ?y)))
</p>
<p>(:operator (!hail ?vehicle ?location)
</p>
<p>()
</p>
<p>((at ?vehicle ?location)))
</p>
<p>(:operator (!wait-for ?bus ?location)
</p>
<p>()
</p>
<p>((at ?bus ?location)))
</p>
<p>(:operator (!ride ?vehicle ?a ?b)
</p>
<p>((at ?a) (at ?vehicle ?a))
</p>
<p>((at ?b) (at ?vehicle ?b)))
</p>
<p>(:operator (!set-cash ?old ?new)
</p>
<p>((have-cash ?old))
</p>
<p>((have-cash ?new)))
</p>
<p>(:operator (!walk ?here ?there)
</p>
<p>((at ?here))
</p>
<p>((at ?there)))
</p>
<p>))
 </p></td><td>(defdomain travel

<p>(
</p>
<p>(:- (have-taxi-fare ?distance)
</p>
<p>((have-cash ?m)
</p>
<p>(call &gt;= ?m (call + 1.5 ?distance))))
</p>
<p>(:- (walking-distance ?u ?v)
</p>
<p>good ((weather-is good)<br>
(distance ?u ?v ?w)<br>
(call &lt;= ?w 3))
</p>
<p>bad ( (distance ?u ?v ?w)
</p>
<p>(call &lt;= ?w 0.5)))
</p>
<p>(:method (pay-driver ?fare)
</p>
<p>((have-cash ?m)<br>
(call &gt;= ?m ?fare))
</p>
<p>((!set-cash ?m ( call - ?m ?fare))))
</p>
<p>(:method (travel-to ?q)
</p>
<p>((at ?p) (walking-distance ?p ?q))
</p>
<p>((!walk ?p ?q)))
</p>
<p>(:method (travel-to ?y)
</p>
<p>by-taxi
</p>
<p>((at ?x) (at-taxi-stand ?t ?x)
</p>
<p>(distance ?x ?y ?d) (have-taxi-fare ?d))<br>
((!hail ?t ?x) (!ride ?t ?x ?y)
</p>
<p>(pay-driver (call + 1.50 ?d)))
</p>
<p>by-bus
</p>
<p>((at ?x) (bus-route ?bus ?x ?y))
</p>
<p>((!wait-for ?bus ?x) (pay-driver 1.00)<br>
(!ride ?bus ?x ?y)))
</p>
<p>(:operator (!hail ?vehicle ?location)
</p>
<p>() ()
</p>
<p>((at ?vehicle ?location)))
</p>
<p>(:operator (!wait-for ?bus ?location)
</p>
<p>() ()
</p>
<p>((at ?bus ?location)))
</p>
<p>(:operator (!ride ?vehicle ?a ?b)
</p>
<p>()<br>
((at ?a) (at ?vehicle ?a))
</p>
<p>((at ?b) (at ?vehicle ?b)))
</p>
<p>(:operator (!set-cash ?old ?new)
</p>
<p>((have-cash ?old))
</p>
<p>((have-cash ?old))
</p>
<p>((have-cash ?new)))
</p>
<p>(:operator (!walk ?here ?there)
</p>
<p>((at ?here))
</p>
<p>((at ?here))
</p>
<p>((at ?there)))
</p>
<p>))
</p></td></tr>
<tr><td>(make-problem &rsquo;go-park-rich &rsquo;travel

<p>&lsquo;((distance downtown park 2)
</p>
<p>(distance downtown uptown 8)
</p>
<p>(distance downtown suburb 12)
</p>
<p>(at-taxi-stand taxi1 downtown)
</p>
<p>(at-taxi-stand taxi2 downtown)
</p>
<p>(bus-route bus1 downtown park)
</p>
<p>(bus-route bus2 downtown uptown)
</p>
<p>(bus-route bus3 downtown suburb)
</p>
<p>(at downtown)
</p>
<p>(weather-is good)
</p>
<p>(have-cash 80))
</p>
<p>&rsquo;((travel-to park)))
 </p></td><td>(defproblem go-park-rich travel

<p>((distance downtown park 2)
</p>
<p>(distance downtown uptown 8)
</p>
<p>(distance downtown suburb 12)
</p>
<p>(at-taxi-stand taxi1 downtown)
</p>
<p>(at-taxi-stand taxi2 downtown)
</p>
<p>(bus-route bus1 downtown park)
</p>
<p>(bus-route bus2 downtown uptown)
</p>
<p>(bus-route bus3 downtown suburb)
</p>
<p>(at downtown)
</p>
<p>(weather-is good)
</p>
<p>(have-cash 80))
</p>
<p>((travel-to park)))
</p></td></tr>
<tr><td>(make-problem-set &rsquo;travel

<p>&rsquo;( go-park-broke
</p>
<p>go-park-rich
</p>
<p>))
 </p></td><td>(def-problem-set travel

<p>(go-park-broke
</p>
<p>go-park-rich
</p>
<p>))
</p>
<p>*def-problem-set is not available in JSHOP
</p></td></tr>
<tr><td>(do-problems &rsquo;travel :which :all)</td><td>Works in <small>SHOP3</small> without any changes. Not available in JSHOP.</td></tr>
</table>

<p>To summarize, the changes in syntax are as follows:
</p>
<ul>
<li> Quotes, back quotes and commas are not used in <small>SHOP3</small> except as needed in
general Lisp expressions.

</li><li> <em>make-domain</em> is replaced with <em>defdomain.</em>

</li><li> <em>make-problem</em> is replaced with <em>defproblem.</em>

</li><li> Operators may have preconditions in <small>SHOP3</small>.

</li><li> The tail of an axiom can have names for each of the conjuncts, and the
tail of a method can have names for each of the precondition-tail pairs.
These names are optional.

</li><li> An ordinary list can be differentiated from a predicate or a function by
inserting the optional label, <em>list</em>, before the first element of
the list.

</li><li> In SHOP 1.x it was valid to have methods of the following form, where
<em>e</em> is any Lisp expression:

</li></ul>

<blockquote>
<p>(:method (varSubtasks ?tasklist)
</p>
<p>((precondition))<br>
<em>e</em>)
</p>
<p>This kind of method is not supported in <small>SHOP3</small>.
</p></blockquote>
<p>Note that in many cases, <small>SHOP3</small> is able to process SHOP 1.x syntax (i.e.,
<small>SHOP3</small> is partially backward compatible). For example, the old
<em>make-domain</em> and <em>make-problem</em> forms can be handled by
<small>SHOP3</small>. It is recommended, however, that new domains be written using the
new <small>SHOP3</small> forms.
</p>
<hr>
<span id="SHOP-1x-Functionality-Comparison"></span><div class="header">
<p>
Previous: <a href="#SHOP-1x-Syntax-Comparison" accesskey="p" rel="prev">SHOP 1x Syntax Comparison</a>, Up: <a href="#Version-Differences" accesskey="u" rel="up">Version Differences</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="SHOP-1_002ex-Functionality-Comparison"></span><h3 class="section">10.2 SHOP 1.x Functionality Comparison</h3>
<span id="g_t_0023shop_002d1_002ex_002dfunctionality_002dcomparison"></span><p>The following are some key differences between the functionality of SHOP
1.x and <small>SHOP3</small>:
</p>
<ul>
<li> Unlike SHOP 1.x, <small>SHOP3</small> allows the combination of partially ordered and
fully ordered tasks through the use of the :unordered and :ordered
keywords.

</li></ul>

<ul>
<li> The following keywords in <small>SHOP3</small> domain definitions are not supported in
SHOP 1.x: or, assign, sort-by, forall. The functionality associated with
those keywords is not available in SHOP 1.x.

</li><li> The not keyword in SHOP 1.x can only be applied to individual atoms, not
to arbitrary logical expressions.

</li><li> The :optimize-cost, :time-limit, and :plan-tree keyword arguments for
<small>SHOP3</small> are not supported in SHOP 1.x. The functionality associated with
those keywords is not available in SHOP 1.x.

</li><li> The debugging features in <small>SHOP3</small> (see Sections 5.2 and 5.3) are not
present in SHOP 1.x.

</li><li> <small>SHOP3</small> version 1.1 includes a Java interface. SHOP 1.x has no such
interface.

</li></ul>

<p><small>SHOP3</small> is largely backward compatible with SHOP 1.x . <small>SHOP3</small> can run most
SHOP 1.x knowledge bases with only little or no modification.
</p>
<hr>
<span id="General-Notes-on-SHOP3"></span><div class="header">
<p>
Next: <a href="#Acknowledgments" accesskey="n" rel="next">Acknowledgments</a>, Previous: <a href="#Version-Differences" accesskey="p" rel="prev">Version Differences</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="General-Notes-on-SHOP3-1"></span><h2 class="chapter">11 General Notes on <small>SHOP3</small></h2>
<ol>
<li> Since the null conjunct is always true, an axiom of the form (:- a nil)
is equivalent to asserting the atom <em>a</em> as a basic fact. The
difference is that the expression (:- a nil) is what one would put into
the set of axioms for the problem domain, whereas the atom <em>a</em> is
what one would put into a state description.&nbsp; An atom <em>a</em> in the
state description can be deleted by an operator. However, if we have an
axiom (:- a nil), then <em>a</em> is always true, no operator can change
that.

</li><li> An axiom with several conjuncts in its tail has a different semantics
than what you would get by making each conjunct the tail of a separate
axiom. For example, consider the following axiom lists:

</li></ol>

<p>&nbsp;
</p>
<blockquote>
<p>X<sub>1</sub> =&nbsp;((:- (a ?x) ((b ?x))
</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ((c ?x)))))
</p>
<p>X<sub>2</sub> =&nbsp;((:- (a ?x) ((b ?x)))
</p>
<p>&nbsp; (:- (a ?x) ((c ?x))))
</p>
<p>In X<sub>1</sub>, the single axiom acts like an <em>if-then-else</em>: if ((b
?x)) is true then find-satisfiers returns the satisfiers for (b ?x);
otherwise if ((c ?x)) is true then it returns the satisfiers for (c ?x).
For example,
</p>
<p>(find-satisfiers &rsquo;((a ?u)) &rsquo;((b 2) (c 3)))
</p></blockquote>
<p>would return
</p>
<blockquote>
<p>(((?u . 2))).
</p>
<p>On the other hand, in X<sub>2</sub>, the set of axioms acts like a logical
&quot;or&quot;: find-satisfiers returns every satisfier for (b ?x) and every
satisfier for (c ?x). In this case,
</p>
<p>(find-satisfiers &rsquo;((a ?u)) &rsquo;((b 2) (c 3)))
</p></blockquote>
<p>would return
</p>
<blockquote>
<p>(((?u . 2)) ((?u . 3))).
</p></blockquote>
<ol start="3">
<li> Since a primitive task name is basically a call to an operator, you
should never create a set of methods and operators that has more than
one operator for the same primitive task. Otherwise, your plans will be
ambiguous.

</li><li> The following two calls to find-plans <small>SHOP3</small> will find the same set of
all shallowest plans, but in the first case <small>SHOP3</small> will use a depth-first
search and in the second case it will use an iterative-deepening search:

</li></ol>

<blockquote>
<p>(find-plans &rsquo;p :which :all-shallowest)
</p>
<p>(find-plans &rsquo;p :which :id-all)
</p>
<p>Likewise, the following two calls to <small>SHOP3</small> will both find the same
shallowest plan, but in the first case <small>SHOP3</small> will use a depth-first
search and in the second case it will use an iterative-deepening search:
</p>
<p>(find-plans &rsquo;p :which :shallowest)
</p>
<p>(find-plans &rsquo;p :which :id-first)
</p></blockquote>

<hr>
<span id="Acknowledgments"></span><div class="header">
<p>
Next: <a href="#References" accesskey="n" rel="next">References</a>, Previous: <a href="#General-Notes-on-SHOP3" accesskey="p" rel="prev">General Notes on SHOP3</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Acknowledgments-1"></span><h2 class="chapter">12 Acknowledgments</h2>
<span id="g_t_0023acknowledgments"></span><p>Original University of Maryland work on <small>SHOP3</small> was supported in part by
the following grants, contracts, and awards: Air Force Research
Laboratory F30602-99-1-0013 and F30602-00-2-0505, Army Research
Laboratory DAAL01-97-K0135, and National Science Foundation DMI-9713718,
and the University of Maryland General Research Board.
</p>
<p>SIFT, LLC work on <small>SHOP3</small> has been supported by DARPA SBIR contract
DAAH01-03-C-R177, Army AFDD contract NAS-0155(MJH), Delivery Order 920,
by the Air Force Research Laboratory (AFRL) under contract
FA8750-16-C-0182,and by Contract FA8650-11-C-7191 with the US Defense
Advanced Research Projects Agency (DARPA) and the Air Force Research
Laboratory.
</p>
<p>SIFT LLC work was also supported by Internal Research and Development.
</p>
<p>Joint SIFT, LLC and University of Maryland work was supported by DARPA
contract FA8650-06-C-7606.
</p>
<p>Recent SIFT work on the manual was supported by the Defense Advanced
Research Projects Agency (DARPA) and the Air Force Research Laboratory
under Contract No. FA8750-17-C-0184.
</p>
<p>Any opinions, findings and conclusions or recommendations expressed in
this material are those of the author(s) and do not necessarily reflect
the views of the Defense Advanced Research Projects Agency (DARPA), the
Department of Defense, the National Science Foundation, the University
of Maryland, SIFT, or the United States Government.  
</p>
<hr>
<span id="References"></span><div class="header">
<p>
Next: <a href="#Function-Index" accesskey="n" rel="next">Function Index</a>, Previous: <a href="#Acknowledgments" accesskey="p" rel="prev">Acknowledgments</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="References-1"></span><h2 class="chapter">13 References</h2>
<span id="g_t_0023references"></span><p>[Dean and Boddy, 1998] T. Dean and M. Boddy. An analysis of
time-dependent planning. In <em>AAAI-88</em>, 1988.
</p>
<p>[Nau <em>et al.</em>, 1999] D. Nau, Y. Cao, A. Lotem, and H. MuÃ±oz-Avila.
SHOP: Simple Hierarchical Ordered Planner. In <em>IJCAI-99</em>, 1999.
</p>
<p>[Nau <em>et al.</em>, 2000] D. S. Nau, Y. Cao, A. Lotem, and H.
MuÃ±oz-Avila. SHOP and M-SHOP: Planning with Ordered Task Decomposition.
Tech report TR 4157, University of Maryland, College Park, MD, June
2000.
</p>
<p>[Nau <em>et al.</em>, 2001] D. S. Nau, H. MuÃ±oz-Avila Y. Cao, A. Lotem,
and.S. Mitchell. Totally Ordered Planning with Partially Ordered
Subtasks. In <em>IJCAI-01</em>, 2001.
</p>
<hr>
<span id="Function-Index"></span><div class="header">
<p>
Next: <a href="#Type-and-Class-Index" accesskey="n" rel="next">Type and Class Index</a>, Previous: <a href="#References" accesskey="p" rel="prev">References</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Function-and-Macro-Index"></span><h2 class="unnumbered">Function and Macro Index</h2>
<table><tr><th valign="top">Jump to: &nbsp; </th><td><a class="summary-letter" href="#Function-Index_fn_letter-A"><b>A</b></a>
 &nbsp; 
<a class="summary-letter" href="#Function-Index_fn_letter-B"><b>B</b></a>
 &nbsp; 
<a class="summary-letter" href="#Function-Index_fn_letter-D"><b>D</b></a>
 &nbsp; 
<a class="summary-letter" href="#Function-Index_fn_letter-E"><b>E</b></a>
 &nbsp; 
<a class="summary-letter" href="#Function-Index_fn_letter-F"><b>F</b></a>
 &nbsp; 
<a class="summary-letter" href="#Function-Index_fn_letter-G"><b>G</b></a>
 &nbsp; 
<a class="summary-letter" href="#Function-Index_fn_letter-M"><b>M</b></a>
 &nbsp; 
<a class="summary-letter" href="#Function-Index_fn_letter-P"><b>P</b></a>
 &nbsp; 
<a class="summary-letter" href="#Function-Index_fn_letter-Q"><b>Q</b></a>
 &nbsp; 
<a class="summary-letter" href="#Function-Index_fn_letter-S"><b>S</b></a>
 &nbsp; 
<a class="summary-letter" href="#Function-Index_fn_letter-T"><b>T</b></a>
 &nbsp; 
<a class="summary-letter" href="#Function-Index_fn_letter-U"><b>U</b></a>
 &nbsp; 
<a class="summary-letter" href="#Function-Index_fn_letter-V"><b>V</b></a>
 &nbsp; 
</td></tr></table>
<table class="index-fn" border="0">
<tr><td></td><th align="left">Index Entry</th><td>&nbsp;</td><th align="left"> Section</th></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th id="Function-Index_fn_letter-A">A</th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-anonymous_002dvar_002dp-_005bshopunif_005d"><code>anonymous-var-p [shopunif]</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#The-SHOP-Unifier">The SHOP Unifier</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-anonymous_002dvar_002dp-_005bshopunif_005d-1"><code>anonymous-var-p [shopunif]</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#The-SHOP-Unifier">The SHOP Unifier</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-apply_002dsubstitution-_005bshopunif_005d"><code>apply-substitution [shopunif]</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#The-SHOP-Unifier">The SHOP Unifier</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-apply_002dsubstitution-_005bshopunif_005d-1"><code>apply-substitution [shopunif]</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#The-SHOP-Unifier">The SHOP Unifier</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th id="Function-Index_fn_letter-B">B</th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-binding_002dlist_002dvalue-_005bshopunif_005d"><code>binding-list-value [shopunif]</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#The-SHOP-Unifier">The SHOP Unifier</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-binding_002dlist_002dvalue-_005bshopunif_005d-1"><code>binding-list-value [shopunif]</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#The-SHOP-Unifier">The SHOP Unifier</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-binding_002dval-_005bshopunif_005d"><code>binding-val [shopunif]</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#The-SHOP-Unifier">The SHOP Unifier</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-binding_002dval-_005bshopunif_005d-1"><code>binding-val [shopunif]</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#The-SHOP-Unifier">The SHOP Unifier</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-binding_002dvar-_005bshopunif_005d"><code>binding-var [shopunif]</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#The-SHOP-Unifier">The SHOP Unifier</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-binding_002dvar-_005bshopunif_005d-1"><code>binding-var [shopunif]</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#The-SHOP-Unifier">The SHOP Unifier</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th id="Function-Index_fn_letter-D">D</th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-def_002dproblem_002dset"><code>def-problem-set</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Planning-Problem-Set">Planning Problem Set</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-defproblem"><code>defproblem</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Planning-Problem">Planning Problem</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-defproblem-1"><code>defproblem</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Planning-Problem">Planning Problem</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-defproblem-2"><code>defproblem</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Planning-Problem">Planning Problem</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-do_002dproblems"><code>do-problems</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#do_002dproblems">do-problems</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-do_002dproblems-1"><code>do-problems</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#do_002dproblems">do-problems</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th id="Function-Index_fn_letter-E">E</th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-external_002daccess_002dhook"><code>external-access-hook</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Hook-Routines">Hook Routines</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th id="Function-Index_fn_letter-F">F</th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-find_002dplans"><code>find-plans</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#find_002dplans">find-plans</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-find_002dplans-1"><code>find-plans</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#find_002dplans">find-plans</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-find_002dplans_002dstack"><code>find-plans-stack</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#find_002dplans_002dstack">find-plans-stack</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-find_002dplans_002dstack-1"><code>find-plans-stack</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#find_002dplans_002dstack">find-plans-stack</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-find_002dsatisfiers-_005bshopthpr_005d"><code>find-satisfiers [shopthpr]</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#The-SHOP-Theorem-Prover">The SHOP Theorem Prover</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-find_002dsatisfiers-_005bshopthpr_005d-1"><code>find-satisfiers [shopthpr]</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#The-SHOP-Theorem-Prover">The SHOP Theorem Prover</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th id="Function-Index_fn_letter-G">G</th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-graph_002denhanced_002dplan_002dtree-_005bspg_005d"><code>graph-enhanced-plan-tree [spg]</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Plan-Grapher">Plan Grapher</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-graph_002denhanced_002dplan_002dtree-_005bspg_005d-1"><code>graph-enhanced-plan-tree [spg]</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Plan-Grapher">Plan Grapher</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-graph_002dplan_002dtree-_005bspg_005d"><code>graph-plan-tree [spg]</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Plan-Grapher">Plan Grapher</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-graph_002dplan_002dtree-_005bspg_005d-1"><code>graph-plan-tree [spg]</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Plan-Grapher">Plan Grapher</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-groundp-_005bshopunif_005d"><code>groundp [shopunif]</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#The-SHOP-Unifier">The SHOP Unifier</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-groundp-_005bshopunif_005d-1"><code>groundp [shopunif]</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#The-SHOP-Unifier">The SHOP Unifier</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th id="Function-Index_fn_letter-M">M</th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-make_002dbinding_002dlist-_005bshopunif_005d"><code>make-binding-list [shopunif]</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#The-SHOP-Unifier">The SHOP Unifier</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-make_002dbinding_002dlist-_005bshopunif_005d-1"><code>make-binding-list [shopunif]</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#The-SHOP-Unifier">The SHOP Unifier</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-make_002dproblem"><code>make-problem</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Planning-Problem">Planning Problem</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-make_002dproblem-1"><code>make-problem</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Planning-Problem">Planning Problem</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th id="Function-Index_fn_letter-P">P</th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-plan_002dfound_002dhook"><code>plan-found-hook</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Hook-Routines">Hook Routines</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-print_002dcurrent_002dplan"><code>print-current-plan</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Other-Debugging-Features">Other Debugging Features</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-print_002dcurrent_002dstate"><code>print-current-state</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Other-Debugging-Features">Other Debugging Features</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-print_002dcurrent_002dtasks"><code>print-current-tasks</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Other-Debugging-Features">Other Debugging Features</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th id="Function-Index_fn_letter-Q">Q</th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-query-_005bshopthpr_005d"><code>query [shopthpr]</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#The-SHOP-Theorem-Prover">The SHOP Theorem Prover</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-query-_005bshopthpr_005d-1"><code>query [shopthpr]</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#The-SHOP-Theorem-Prover">The SHOP Theorem Prover</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th id="Function-Index_fn_letter-S">S</th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-shop_002dtrace"><code>shop-trace</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Tracing">Tracing</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-shop_002dtrace-1"><code>shop-trace</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Tracing">Tracing</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-shop_002dtrace-2"><code>shop-trace</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Tracing">Tracing</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-shop_002duntrace"><code>shop-untrace</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Tracing">Tracing</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-shorter_002dplan"><code>shorter-plan</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Plans">Plans</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-shorter_002dplan-1"><code>shorter-plan</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Plans">Plans</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-standardize-_005bshopunif_005d"><code>standardize [shopunif]</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#The-SHOP-Unifier">The SHOP Unifier</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-standardize-_005bshopunif_005d-1"><code>standardize [shopunif]</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#The-SHOP-Unifier">The SHOP Unifier</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th id="Function-Index_fn_letter-T">T</th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-trace_002dquery_002dhook"><code>trace-query-hook</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Hook-Routines">Hook Routines</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th id="Function-Index_fn_letter-U">U</th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-unify-_005bshopunif_005d"><code>unify [shopunif]</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#The-SHOP-Unifier">The SHOP Unifier</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-unify-_005bshopunif_005d-1"><code>unify [shopunif]</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#The-SHOP-Unifier">The SHOP Unifier</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-unify_002dfail-_005bshopunif_005d"><code>unify-fail [shopunif]</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#The-SHOP-Unifier">The SHOP Unifier</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-unify_002dfail-_005bshopunif_005d-1"><code>unify-fail [shopunif]</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#The-SHOP-Unifier">The SHOP Unifier</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-unify_002dfail_002dp-_005bshopunif_005d"><code>unify-fail-p [shopunif]</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#The-SHOP-Unifier">The SHOP Unifier</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-unify_002dfail_002dp-_005bshopunif_005d-1"><code>unify-fail-p [shopunif]</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#The-SHOP-Unifier">The SHOP Unifier</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-unify_002dp-_005bshopunif_005d"><code>unify-p [shopunif]</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#The-SHOP-Unifier">The SHOP Unifier</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-unify_002dp-_005bshopunif_005d-1"><code>unify-p [shopunif]</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#The-SHOP-Unifier">The SHOP Unifier</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th id="Function-Index_fn_letter-V">V</th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-variable_002dp-_005bshopunif_005d"><code>variable-p [shopunif]</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#The-SHOP-Unifier">The SHOP Unifier</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-variable_002dp-_005bshopunif_005d-1"><code>variable-p [shopunif]</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#The-SHOP-Unifier">The SHOP Unifier</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-variablep-_005bshopunif_005d"><code>variablep [shopunif]</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#The-SHOP-Unifier">The SHOP Unifier</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-variablep-_005bshopunif_005d-1"><code>variablep [shopunif]</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#The-SHOP-Unifier">The SHOP Unifier</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
</table>
<table><tr><th valign="top">Jump to: &nbsp; </th><td><a class="summary-letter" href="#Function-Index_fn_letter-A"><b>A</b></a>
 &nbsp; 
<a class="summary-letter" href="#Function-Index_fn_letter-B"><b>B</b></a>
 &nbsp; 
<a class="summary-letter" href="#Function-Index_fn_letter-D"><b>D</b></a>
 &nbsp; 
<a class="summary-letter" href="#Function-Index_fn_letter-E"><b>E</b></a>
 &nbsp; 
<a class="summary-letter" href="#Function-Index_fn_letter-F"><b>F</b></a>
 &nbsp; 
<a class="summary-letter" href="#Function-Index_fn_letter-G"><b>G</b></a>
 &nbsp; 
<a class="summary-letter" href="#Function-Index_fn_letter-M"><b>M</b></a>
 &nbsp; 
<a class="summary-letter" href="#Function-Index_fn_letter-P"><b>P</b></a>
 &nbsp; 
<a class="summary-letter" href="#Function-Index_fn_letter-Q"><b>Q</b></a>
 &nbsp; 
<a class="summary-letter" href="#Function-Index_fn_letter-S"><b>S</b></a>
 &nbsp; 
<a class="summary-letter" href="#Function-Index_fn_letter-T"><b>T</b></a>
 &nbsp; 
<a class="summary-letter" href="#Function-Index_fn_letter-U"><b>U</b></a>
 &nbsp; 
<a class="summary-letter" href="#Function-Index_fn_letter-V"><b>V</b></a>
 &nbsp; 
</td></tr></table>

<hr>
<span id="Type-and-Class-Index"></span><div class="header">
<p>
Next: <a href="#Variable-Index" accesskey="n" rel="next">Variable Index</a>, Previous: <a href="#Function-Index" accesskey="p" rel="prev">Function Index</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Type-and-Class-Index-1"></span><h2 class="unnumbered">Type and Class Index</h2>
<table><tr><th valign="top">Jump to: &nbsp; </th><td><a class="summary-letter" href="#Type-and-Class-Index_tp_letter-B"><b>B</b></a>
 &nbsp; 
<a class="summary-letter" href="#Type-and-Class-Index_tp_letter-E"><b>E</b></a>
 &nbsp; 
<a class="summary-letter" href="#Type-and-Class-Index_tp_letter-P"><b>P</b></a>
 &nbsp; 
<a class="summary-letter" href="#Type-and-Class-Index_tp_letter-T"><b>T</b></a>
 &nbsp; 
</td></tr></table>
<table class="index-tp" border="0">
<tr><td></td><th align="left">Index Entry</th><td>&nbsp;</td><th align="left"> Section</th></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th id="Type-and-Class-Index_tp_letter-B">B</th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-binding-_005bshopunif_005d"><code>binding [shopunif]</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#The-SHOP-Unifier">The SHOP Unifier</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-binding-_005bshopunif_005d-1"><code>binding [shopunif]</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#The-SHOP-Unifier">The SHOP Unifier</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th id="Type-and-Class-Index_tp_letter-E">E</th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-enhanced_002dplan_002dtree_002dgraph-_005bspg_005d"><code>enhanced-plan-tree-graph [spg]</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Plan-Grapher">Plan Grapher</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-enhanced_002dplan_002dtree_002dgraph-_005bspg_005d-1"><code>enhanced-plan-tree-graph [spg]</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Plan-Grapher">Plan Grapher</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th id="Type-and-Class-Index_tp_letter-P">P</th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-plan_002dtree_002dgraph-_005bspg_005d"><code>plan-tree-graph [spg]</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Plan-Grapher">Plan Grapher</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-plan_002dtree_002dgraph-_005bspg_005d-1"><code>plan-tree-graph [spg]</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Plan-Grapher">Plan Grapher</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th id="Type-and-Class-Index_tp_letter-T">T</th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-thpr_002ddomain-_005bshopthpr_005d"><code>thpr-domain [shopthpr]</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#The-SHOP-Theorem-Prover">The SHOP Theorem Prover</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-thpr_002ddomain-_005bshopthpr_005d-1"><code>thpr-domain [shopthpr]</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#The-SHOP-Theorem-Prover">The SHOP Theorem Prover</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
</table>
<table><tr><th valign="top">Jump to: &nbsp; </th><td><a class="summary-letter" href="#Type-and-Class-Index_tp_letter-B"><b>B</b></a>
 &nbsp; 
<a class="summary-letter" href="#Type-and-Class-Index_tp_letter-E"><b>E</b></a>
 &nbsp; 
<a class="summary-letter" href="#Type-and-Class-Index_tp_letter-P"><b>P</b></a>
 &nbsp; 
<a class="summary-letter" href="#Type-and-Class-Index_tp_letter-T"><b>T</b></a>
 &nbsp; 
</td></tr></table>


<hr>
<span id="Variable-Index"></span><div class="header">
<p>
Next: <a href="#Concept-Index" accesskey="n" rel="next">Concept Index</a>, Previous: <a href="#Type-and-Class-Index" accesskey="p" rel="prev">Type and Class Index</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Variable-Index-1"></span><h2 class="unnumbered">Variable Index</h2>
<table><tr><th valign="top">Jump to: &nbsp; </th><td><a class="summary-letter" href="#Variable-Index_vr_symbol-1"><b>*</b></a>
</td></tr></table>
<table class="index-vr" border="0">
<tr><td></td><th align="left">Index Entry</th><td>&nbsp;</td><th align="left"> Section</th></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th id="Variable-Index_vr_symbol-1">*</th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002abreak_002don_002dbacktrack_002a"><code>*break-on-backtrack*</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Other-Debugging-Features">Other Debugging Features</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002acurrent_002dplan_002a"><code>*current-plan*</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Other-Debugging-Features">Other Debugging Features</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002acurrent_002dstate_002a"><code>*current-state*</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Other-Debugging-Features">Other Debugging Features</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002acurrent_002dtasks_002a"><code>*current-tasks*</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Other-Debugging-Features">Other Debugging Features</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002adomain_002a"><code>*domain*</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Extended-form">Extended form</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002aproblem_002a"><code>*problem*</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Planning-Problem">Planning Problem</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_002awhich_002a"><code>*which*</code></a>:</td><td>&nbsp;</td><td valign="top"><a href="#Common-Keyword-Arguments">Common Keyword Arguments</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
</table>
<table><tr><th valign="top">Jump to: &nbsp; </th><td><a class="summary-letter" href="#Variable-Index_vr_symbol-1"><b>*</b></a>
</td></tr></table>

<hr>
<span id="Concept-Index"></span><div class="header">
<p>
Next: <a href="#Colophon" accesskey="n" rel="next">Colophon</a>, Previous: <a href="#Variable-Index" accesskey="p" rel="prev">Variable Index</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Concept-Index-1"></span><h2 class="unnumbered">Concept Index</h2>
<table><tr><th valign="top">Jump to: &nbsp; </th><td><a class="summary-letter" href="#Concept-Index_cp_symbol-1"><b>:</b></a>
 &nbsp; 
<br>
<a class="summary-letter" href="#Concept-Index_cp_letter-A"><b>A</b></a>
 &nbsp; 
<a class="summary-letter" href="#Concept-Index_cp_letter-D"><b>D</b></a>
 &nbsp; 
<a class="summary-letter" href="#Concept-Index_cp_letter-E"><b>E</b></a>
 &nbsp; 
<a class="summary-letter" href="#Concept-Index_cp_letter-H"><b>H</b></a>
 &nbsp; 
<a class="summary-letter" href="#Concept-Index_cp_letter-I"><b>I</b></a>
 &nbsp; 
<a class="summary-letter" href="#Concept-Index_cp_letter-P"><b>P</b></a>
 &nbsp; 
<a class="summary-letter" href="#Concept-Index_cp_letter-S"><b>S</b></a>
 &nbsp; 
</td></tr></table>
<table class="index-cp" border="0">
<tr><td></td><th align="left">Index Entry</th><td>&nbsp;</td><th align="left"> Section</th></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th id="Concept-Index_cp_symbol-1">:</th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-_003ainclude">:include</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Inclusion-directives">Inclusion directives</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th id="Concept-Index_cp_letter-A">A</th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-anonymous-variables">anonymous variables</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Syntax-Checks">Syntax Checks</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th id="Concept-Index_cp_letter-D">D</th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-domain-inclusion">domain inclusion</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Inclusion-directives">Inclusion directives</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th id="Concept-Index_cp_letter-E">E</th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-explanation">explanation</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Common-Keyword-Arguments">Common Keyword Arguments</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th id="Concept-Index_cp_letter-H">H</th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-hook_002droutines">hook-routines</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Hook-Routines">Hook Routines</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th id="Concept-Index_cp_letter-I">I</th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-include-directives">include directives</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Inclusion-directives">Inclusion directives</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-internal-operators">internal operators</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Operators">Operators</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th id="Concept-Index_cp_letter-P">P</th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-planning-problem">planning problem</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Planning-Problem">Planning Problem</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-plans">plans</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Plans">Plans</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th id="Concept-Index_cp_letter-S">S</th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-singleton-variables">singleton variables</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Syntax-Checks">Syntax Checks</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
</table>
<table><tr><th valign="top">Jump to: &nbsp; </th><td><a class="summary-letter" href="#Concept-Index_cp_symbol-1"><b>:</b></a>
 &nbsp; 
<br>
<a class="summary-letter" href="#Concept-Index_cp_letter-A"><b>A</b></a>
 &nbsp; 
<a class="summary-letter" href="#Concept-Index_cp_letter-D"><b>D</b></a>
 &nbsp; 
<a class="summary-letter" href="#Concept-Index_cp_letter-E"><b>E</b></a>
 &nbsp; 
<a class="summary-letter" href="#Concept-Index_cp_letter-H"><b>H</b></a>
 &nbsp; 
<a class="summary-letter" href="#Concept-Index_cp_letter-I"><b>I</b></a>
 &nbsp; 
<a class="summary-letter" href="#Concept-Index_cp_letter-P"><b>P</b></a>
 &nbsp; 
<a class="summary-letter" href="#Concept-Index_cp_letter-S"><b>S</b></a>
 &nbsp; 
</td></tr></table>

<hr>
<span id="Colophon"></span><div class="header">
<p>
Previous: <a href="#Concept-Index" accesskey="p" rel="prev">Concept Index</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Function-Index" title="Index" rel="index">Index</a>]</p>
</div>
<span id="Colophon-1"></span><h2 class="unnumbered">Colophon</h2>

<p>This manual is maintained in Texinfo, and automatically translated
into other forms (e.g. HTML or pdf). If you&rsquo;re <em>reading</em> this
manual in one of these non-Texinfo translated forms, that&rsquo;s fine, but
if you want to <em>modify</em> this manual, you are strongly advised to
seek out a Texinfo version and modify that instead of modifying a
translated version.
</p>
<p>This manual was made possible in part by the <code>SB-TEXINFO</code> library
provided by Nikodemus Siivola and Rudi Schlatte, for which we are very grateful.
</p>

<div class="footnote">
<hr>
<h4 class="footnotes-heading">Footnotes</h4>

<h3><a id="FOOT1" href="#DOCF1">(1)</a></h3>
<p>From <em>Automated Planning: Theory and
Practice,</em> Ghallab, Nau and Traverso, Morgan Kaufmann, 2004.</p>
<h3><a id="FOOT2" href="#DOCF2">(2)</a></h3>
<p>The term
âclassâ here is meant <em>informally;</em> the reader should draw no
conclusions about programming language classes in the SHOP
implementation. &ndash; <em>rpg</em></p>
<h3><a id="FOOT3" href="#DOCF3">(3)</a></h3>
<p>If you don&rsquo;t know what this means,
you may safely ignore it.</p>
</div>
<hr>



</body>
</html>
